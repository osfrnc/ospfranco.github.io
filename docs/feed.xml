<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://ospfranco.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://ospfranco.com/" rel="alternate" type="text/html" /><updated>2024-06-25T22:48:32+02:00</updated><id>https://ospfranco.com/feed.xml</id><title type="html">Oscar Franco</title><author><name>Oscar Franco</name></author><entry><title type="html">Client guide to React Native modules</title><link href="https://ospfranco.com/client-guide-to-react-native-modules/" rel="alternate" type="text/html" title="Client guide to React Native modules" /><published>2024-06-25T00:00:00+02:00</published><updated>2024-06-25T00:00:00+02:00</updated><id>https://ospfranco.com/client%20guide%20to%20react%20native%20modules</id><content type="html" xml:base="https://ospfranco.com/client-guide-to-react-native-modules/"><![CDATA[<p>Let’s play the following scenario: You are my client and I’m me. You ask “Oscar, we want to port our SDK/Library/module to React Native, but all this JSI, Turbo Module stuff is confusing, can you help us?” the answer dear client is obviously yes. However, I’m a bit tired of explaining the same concepts again and again, so I will point you to this article.</p>

<blockquote>
  <p>If you are a RN dev you can skip this, this is an overview of React Native modules meant for people not in the React Native ecosystem. No new information or in-depth technical knowledge is here, just enough for adjacent people can get a grip of the terminology and why are they paying their hard earned money to some RN consultant to write Javascript.</p>
</blockquote>

<h1 id="in-the-beginning-there-was-json">In the beginning there was JSON</h1>

<p>How do you pass data between JavaScript, a interpreted language that runs on C++ to native runtimes of iOS (Swift/ObjC) and Android (Java/Kotlin)? easy! JSON. You serialize your data and every native function that you need to call can pass through a narrow tube of message passing. This is what we call the <code>old arch</code> (the usage of JSON is also called the [JSON] bridge) of React Native.</p>

<h2 id="pros">Pros</h2>

<ul>
  <li>It is the easiest of all the methods to create a module. Due to the ease of marking methods and the runtime registration, there is not a lot of setup necessary.</li>
  <li>❗ Old modules are still supported in the <code>new arch</code> (we will talk about it in a bit). In fact there has been a special work put onto them so that they remain compatible at least for extra year while libraries and apps migrate to the new arch.</li>
  <li>If your SDK sends a small amount of data, actually should be more than enough for your needs.</li>
</ul>

<h2 id="cons">Cons</h2>

<ul>
  <li>It is slow and can get stuck when there is a large amount of data being serialized between the JS code and the native runtimes.</li>
  <li>It’s being phased out</li>
</ul>

<h1 id="new-arch">New arch</h1>

<p>React Native used to have a bad reputation for having bad performance. In order to solve this, one of the key problems was the old JSON bridge. So a bunch of concepts/modules/ideas where introduced. The conjunction of the following terms, form what is called <code>new arch</code>:</p>

<h2 id="jsi">JSI</h2>

<p>The first thing to solve is the slow passing data between JS and native. To fix this, the JavaScript Interface was created at meta. It’s basically a bunch of C++ functions that allow to interact with JavaScript from C++ without paying for serialization costs of JSON. You can think of it as Node-API (the way node.js is able to call native code) but a bit shittier since it is not a binary communication protocol but rather a bolt-on with some higher costs but still much faster than before.</p>

<p>The problem when interacting with C++ code though is that it introduces a gap between JavaScript and native. Whenever you run JavaScript code it runs on a JavaScript engine, but actually one should think about this “context” as a virtual machine. It is a context that can be instantiated multiple times actually, though your UI will run on just one of them. As a matter of fact that is how web workers and certain level of parallelism in JavaScript is achieved. Nobody else calls it a virtual machine, but it is one. It reads your JS and keeps a internal state of the code it runs, has it’s own heap and can die out. Most importantly, you cannot just fiddle with it while is interpreting your JS. The functions provided by JSI, allow to do work with this virtual machine/context/runtime by allowing to enqueue callbacks, cast JS values into C++ values, etc.</p>

<p>JSI is the corner stone of the new arch.</p>

<h2 id="fabric">Fabric</h2>

<p>Forget about fabric, it’s about how UI components are rendered and it’s mostly internal. It will have very little influence on your module, with the exception on how your UI components are registered.</p>

<h1 id="turbo-modules">Turbo Modules</h1>

<p>All the internals of RN started to migrate from JSON to interacting with C++. So, we now need a new way to create native modules for React Native. Since now at least some C++ code is needed to interact with native code. Turbo Modules are a solution to this problem. Is it important to know: <code>Turbo Modules</code> are <strong>built</strong> on top of <code>JSI</code>. You can have <code>new arch</code> modules (that use the JSI) without Turbo Modules, but not the other way around. Turbo Modules take a Typescript or Flow file, and then with a ungodly amount of JavaScript generate a bunch of C++ code, that react native then includes in your project. The idea is that they should allow for lazy initialization and keep your JavaScript function definitions synchronized with the actual native implementations without manual intervention.</p>

<h2 id="pros-1">Pros</h2>

<ul>
  <li>Lazy initialization</li>
  <li>Much faster runtime performance</li>
  <li>Synchronized function definitions between JS and native</li>
</ul>

<h2 id="cons-1">Cons</h2>

<ul>
  <li>Much much harder to setup</li>
  <li>Lack of documentation</li>
  <li>Require C++ knowledge and good knowledge of the internals of RN if you deviate from the golden path</li>
</ul>

<h1 id="expo-modules">Expo modules</h1>

<p>Turbo Modules and the necessary knowledge to make use of <code>JSI</code> is not trivial at all. It requires knowledge of C++, ObjC, Kotlin/Java, Java’s JNI, the build systems and most of all knowledge of the internals of RN. The great guys at expo saw from a mile away that for a company/team building an app in React Native, it is pretty much an impossible task to learn how to code all of these by themselves. Therefore they also applied ungodly amounts of Kotlin/Swift magic and bridged their own way of creating native modules.</p>

<h2 id="pros-2">Pros</h2>

<ul>
  <li>Much much more easier to expose native (Swift/Kotlin) functions to JS</li>
  <li>They still use the JSI, so they are quite fast</li>
  <li>Much much easier to create and move around</li>
</ul>

<h2 id="cons-2">Cons</h2>

<ul>
  <li>They <strong>only</strong> run on expo apps</li>
  <li>JSI is C++, Expo Modules are Swift/Kotlin, so <strong>there is</strong> a runtime performance. It’s not nothing, but is more than good enough for the general use case</li>
  <li>The signatures of functions need to be adjusted manually between native and the JS side</li>
</ul>

<h1 id="c-turbo-modules">C++ Turbo Modules</h1>

<p>It’s notable to mention that there are a lot of cases where you don’t want to interact with the native languages (Swift/Kotlin) but you might want to do pure C++ bindings. For some libraries like sqlite, libsql, etc. This is what you want. JSI is C++, your code is C(++). This will be the fastest option in terms of runtime cost, but documentation is super scant, outdated. It is also tricky to setup.</p>

<h1 id="which-should-you-pick">Which should you pick?</h1>

<p>It depends.</p>

<p>You have a small team and want to just call some native Swift/Kotlin and are running Expo already: go for Expo Modules.</p>

<p>You have a C/C++/Rust library and require the most amount of performance: Go for C++ Turbo Module or a custom JSI module.</p>

<p>You want JSI, have some expertise, not on expo: go for Turbo Modules, documentation is scant so this is the least option I recommend</p>

<p>You want to get the ball rolling for now: go for an old arch module</p>

<h1 id="qa">QA</h1>

<p>Q: Is it possible to have a <code>new arch</code> (i.e. Turbo Module) that is compatible with <code>old arch</code>?
A: Yes, but it’s terrible, it takes a lot of work, copying the generated files and modifying the compilation process so that everything runs on both archs. You will definitely need help from one of the agencies or me to get this working properly and maintain it.</p>

<p>Q: But Expo [insert your comment here]
A: Expo Modules are great if they work for you. Use them. It’s fine. Don’t ask me about it though, not an Expo developer.</p>

<p>Q: You say JSI is C++, how come Turbo Modules are ObjC/Kotlin/Java?
A: The same way Expo Modules are Swift/Kotlin. Ungodly amount of conversion between languages. Swift → ObjC++ → C++. Kotlin/Java → JNI (which is SLOW) → C++. You might be returning native objects/scalars when writing your code, but there is a lot of work later to cast stuff all the way to the right C++ abstractions.</p>

<p>Q: Can I write my Turbo Module in Swift?
A: No. Latest versions of Swift (5.9+) improved compatibility with C++, but it still ways to go and the generation scripts and all the internal tooling works with ObjC. You can write a very thin ObjC façade that will call your Swift code. So yes, there is a way to make it work.</p>

<p>Q: When will I be able to write my Turbo Module in Swift?
A: Some day, who knows, go work at Meta and make this a reality :)</p>

<p>Q: Can I write a native module in Rust?
A: Yes, but not directly. Your Rust code needs to expose a C-ABI compatible API, which will then be called from a C++ turbo module, <a href="https://ospfranco.com/post/2024/05/08/react-native-rust-module-guide/">here is a guide</a>. There is also this <a href="https://github.com/laptou/jsi-rs">repo</a> in case you really want to write everything in rust, but I haven’t managed to get it to run, my Rust-Fu is not advanced enough, but it seems to bridge all the JSI code into Rust so you can call all the functions directly from Rust.</p>

<p>Q: What are the pitfalls when writing my native module?
A: There are many, for example you cannot just invoke a JSI/JS function in the middle of your native code. The JS VM might be busy doing something else, if you all of the sudden ask it to allocate memory for a JS object for example, you might corrupt the stack and your entire thing will go kaput. In order to get this you need to schedule a callback using a call invoker, then await on your native code, etc etc. It’s complex to get all of the moving parts working nicely.</p>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[Let’s play the following scenario: You are my client and I’m me. You ask “Oscar, we want to port our SDK/Library/module to React Native, but all this JSI, Turbo Module stuff is confusing, can you help us?” the answer dear client is obviously yes. However, I’m a bit tired of explaining the same concepts again and again, so I will point you to this article.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ospfranco.com/assets/oscar.jpg" /><media:content medium="image" url="https://ospfranco.com/assets/oscar.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Reduce Rust binaries size</title><link href="https://ospfranco.com/rust-reduce-binary-size/" rel="alternate" type="text/html" title="Reduce Rust binaries size" /><published>2024-06-23T00:00:00+02:00</published><updated>2024-06-23T00:00:00+02:00</updated><id>https://ospfranco.com/rust%20reduce%20binary%20size</id><content type="html" xml:base="https://ospfranco.com/rust-reduce-binary-size/"><![CDATA[<p>I find myself writing a lot of Rust nowadays. I’m by no means an expert, but I need to make do with my limited knowledge. A constant problem I’m facing is that the binaries outputted by Rust are huge. This is especially a problem on mobile, where each megabyte counts.</p>

<p>The documentation is a bit confusing, but here is the configuration I ended up using to get somewhat OK sizes. In the <code>cargo.toml</code> file:</p>

<pre><code class="language-toml">[profile.release] # When compiling in release mode
debug = false # Exclude debug symbols
strip = "symbols" # Exclude the rest of the symbols
# opt-level = "z" # Did not use this, but it equals C++'s optimize for size (O3?)
lto = true # Link time optimization, not sure what this does but it helps reduce the size
</code></pre>

<h1 id="cargo-bloat">Cargo Bloat</h1>

<p>I haven’t fully explored what this tool can do, but it does point to large sections of the code. Install it with <code>cargo install cargo-bloat</code> and then run:</p>

<pre><code>cargo bloat --release --target=&lt;your-target&gt;
</code></pre>

<h1 id="building-both-a-static-and-dylib">Building both a static and dylib</h1>

<p>In my experience static binaries on iOS are OK, but on Android they can be huge. Ideally you would specify <code>crate-type = ['staticlib', 'dylib']</code> and just be on your merry way, however, it seems there is a bug in the rust compiles and it bloats the static lib massively. In order to get a static binary for iOS and a dynamic one for Android you can set <code>crate-type = ['dylib']</code> and change the compilation command for iOS to <code>cargo rustc --crate-type=staticlib ...</code></p>

<h1 id="openssl">OpenSSL</h1>

<p>The OpenSSL adds a lot of weight to a crate unless you need it, you can use <a href="https://crates.io/crates/ring">ring</a> which reduced further 4 MB to 6 MB of my crate.</p>

<h1 id="results">Results</h1>

<p>Using all the compile optimizations, I was able to reduce the output of one of my binaries from 66 MB to 24.7 MB. It’s still large but better.</p>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[I find myself writing a lot of Rust nowadays. I’m by no means an expert, but I need to make do with my limited knowledge. A constant problem I’m facing is that the binaries outputted by Rust are huge. This is especially a problem on mobile, where each megabyte counts.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ospfranco.com/assets/oscar.jpg" /><media:content medium="image" url="https://ospfranco.com/assets/oscar.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Writting tests for Tauri Rust Commands</title><link href="https://ospfranco.com/writting-tests-for-tauri-rust-commands/" rel="alternate" type="text/html" title="Writting tests for Tauri Rust Commands" /><published>2024-06-05T00:00:00+02:00</published><updated>2024-06-05T00:00:00+02:00</updated><id>https://ospfranco.com/writting%20tests%20for%20tauri%20rust%20commands</id><content type="html" xml:base="https://ospfranco.com/writting-tests-for-tauri-rust-commands/"><![CDATA[<p>I’m now in charge of a Tauri app and there is a lot of native Rust functionality that needs to be exposed to the JS side. Like any principled dev I want to write tests for my code.</p>

<p>The official documentation says one should write e2e tests with a UI simulation framework to test this functionality but that is way to cumbersome. I wanted unit tests for my Rust code. Also, I did not have stateless Rust functions, but functions where Tauri itself managed the state, so I needed to mock the entire Tauri app stack.</p>

<p>Credit where is due this <a href="https://stackoverflow.com/questions/77524788/writing-tests-for-tauri-commands-how-to-access-and-manage-state-in-test-environ">Stack Overflow answer</a> provided the info I was looking for.</p>

<p>However Tauri <code>1.6.7</code> broke this functionality and <code>1.6.8</code> fixed it by adding a new parameter.</p>

<p>Without further ado, first you need to add the <code>test</code> feature in your Tauri dependency:</p>

<pre><code class="language-toml">tauri = { version = "1.6.8", features = ["api-all", "updater", "test"] }
</code></pre>

<p>Then you can write your test like so:</p>

<pre><code class="language-rust">#[cfg(test)]
mod tests {
    use super::*;
    use tauri::{
        test::{mock_context, noop_assets, MockRuntime},
        App,
    };

    fn before_each() -&gt; Result&lt;tauri::App&lt;MockRuntime&gt;, std::io::Error&gt; {
        let app = tauri::test::mock_builder()
            .plugin(super::init_plugin())
            .build(mock_context(noop_assets()))
            .unwrap();

        // Any other setup code you need
        Ok(app)
    }

    async fn after_each(app: App&lt;MockRuntime&gt;) {
        // your clean up code
    }

    #[tokio::test]
    async fn should_return_0_with_no_loaded_models() {
        let app = before_each().unwrap();
        let window = app.get_window("main").unwrap();
        let foo = tauri::test::get_ipc_response::&lt;Vec&lt;String&gt;&gt;(
            &amp;window,
            tauri::InvokePayload {
                cmd: "plugin:my_plugin|foo".into(),
                tauri_module: None,
                invoke_key: Some(tauri::test::INVOKE_KEY.into()),
                callback: tauri::api::ipc::CallbackFn(0),
                error: tauri::api::ipc::CallbackFn(1),
                inner: serde_json::json!({}),
            },
        );

        assert!(foo.is_ok());

        after_each(app).await;
    }

}

</code></pre>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[I’m now in charge of a Tauri app and there is a lot of native Rust functionality that needs to be exposed to the JS side. Like any principled dev I want to write tests for my code.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ospfranco.com/assets/oscar.jpg" /><media:content medium="image" url="https://ospfranco.com/assets/oscar.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">React Native Security Guide</title><link href="https://ospfranco.com/react-native-security-guide/" rel="alternate" type="text/html" title="React Native Security Guide" /><published>2024-05-30T00:00:00+02:00</published><updated>2024-05-30T00:00:00+02:00</updated><id>https://ospfranco.com/react%20native%20security%20guide</id><content type="html" xml:base="https://ospfranco.com/react-native-security-guide/"><![CDATA[<p>Like any other software development framework, security should be a top priority when developing React Native applications. However, there are a lot of misconceptions, fueled by the existence of packages and the lack of targeted information.</p>

<p>In this guide, we will explore various security considerations and best practices that every React Native developer should be aware of. If you find anything incorrect or have feedback, please reach out! This is a topic we should all care about.</p>

<h1 id="preface">Preface</h1>

<p>Let’s address this upfront: there is no real way to protect data once it is on the device. A motivated attacker with root or hardware access to the device will eventually be able to bypass security features when storing on-device data. Here is a <a href="https://blog.1password.com/local-threats-device-protections/">1Password write-up</a> that explains this well.</p>

<p>As we are not all building vault apps, this should be our guiding principle: <strong>do not put anything on the user’s device that you cannot afford to leak</strong>.</p>

<p>But that doesn’t mean all is lost. If the attacker does not have direct access to the machine, applying protections will still be a sufficient deterrent (and secure enough unless they actually get hold of the hardware). Using the best-known security practices can make some attacks so cumbersome that they act as a deterrent, so we should still use them.</p>

<h1 id="secrets">Secrets</h1>

<p>Armed with this knowledge, there is one inconvenient truth: <strong>you won’t be able to protect secrets like API keys for third-party services</strong>. No matter how you store or obfuscate them, or what packages promise. You also won’t be able to protect your encryption keys, which means <strong>you won’t be able to protect the encrypted user data</strong> (again, if the hardware is compromised). The difference lies in the fact that user data belongs to the user; they can hack their own app/device and see their data, but they had access to this data anyway. The problematic part is the secrets, as they are shared among your users.</p>

<p>Is there a way to protect secrets? Using a gateway would be one way, but sometimes it is not possible, for example, when using a third-party SDK that ingests the key directly. There is nothing we can do about that.</p>

<p>An important thing to note here is the existence of device attestation. Device attestation is a process where the OS tries to verify that the device and/or app has not been tampered with. There are <a href="https://support.apple.com/guide/deployment/managed-device-attestation-dep28afbde6a/web">APIs for iOS</a> and <a href="https://developer.android.com/privacy-and-security/safetynet/attestation">Android</a>. Some companies offer this as a service with an SDK, allowing you to verify the device/app before sending data to it. However, this is a not very well-explored topic and may be time-consuming or expensive.</p>

<p>With device attestation, you could have a more secure (read: more inconvenient to hack) secret management:</p>

<ol>
  <li>On app start, perform device attestation. If it fails: game over, you tampered with the device/app, so no access.</li>
  <li>On first start, download the secrets and store them in your favorite cryptographically secure storage.</li>
  <li>Combine this with partial keys that need to be fetched from a server each time to decode the secrets/data.</li>
</ol>

<p>Again, once a hacker has access to the device, it’s game over. They can even mess with the OS internals to defeat device attestation, but at least you can make their lives harder.</p>

<p>A final point to mention is packages like <code>react-native-dotenv</code> and <code>react-native-config</code>. I don’t like them because they can be misleading (and have caused me trouble compiling them in the past). These “environment variables” packages still package your environment variables inside the app bundle and then read them at runtime. While they have not intentionally deceived people into thinking they are secure, the naming and the mixing of real environment variables with what they do have at least led unaware developers to think their secrets are secure (speaking from personal experience).</p>

<p>The reason why environment variables in things like Docker containers and server environments are secure is that they reside in memory, are not persisted, and are isolated by running on the server where (hopefully) the only point of entry is a secure HTTP API. This is not the case for mobile apps (regardless of the language/framework you are using).</p>

<h1 id="user-data">User Data</h1>

<p>Given this knowledge, why should we bother encrypting user data? Well, again, if we consider the worst-case scenario, the world is bleak. But if we assume we are running on an untampered device/OS, the fact that we protect data from other apps and script-kiddies is still worthwhile. Most packages have some way of encrypting your data via an encryption key.</p>

<p>Which algorithm they use and if they are actually securing the data is a per-package question. Many of them (at least in the React Native world) have hand-rolled their encryption, use dubious implementations, or are outdated. It’s too much to cover in this article, so I will just give you an ideal workflow that should be secure (barring implementation errors in the libraries themselves):</p>

<h2 id="generate-and-securely-store-your-encryption-key">Generate and Securely Store Your Encryption Key</h2>

<p>Most packages tell you to do this:</p>

<pre><code class="language-ts">const myKey = "password_is_password";

const storage = MyStateLibrary.create({
  encryptionKey: myKey,
});
</code></pre>

<p>The problem with this approach is that anyone can decompile your app and read the value of <code>myKey</code> (no matter how you obfuscate it). This is even worse in React Native, where you can just decompress an APK/IPA and take a look at the minified JS/TS code. I have mentioned in previous articles how looking into the JS bundle can leak valuable business logic and allow competitors to copy functionality.</p>

<p>Here is a better approach to generate and store your encryption key. I’ll use my package <code>op-s2</code> for this, but you can use <a href="https://docs.expo.dev/versions/latest/sdk/securestore/">Expo Secure Store</a> or <a href="https://github.com/oblador/react-native-keychain">react-native-keychain</a> they are all (more-or-less) equivalent but I tried to make op-s2 the simplest. Both work by storing data in the Keychain on iOS and by generating keys with the KeyStore API on Android, which are backed by hardware (when possible on Android) and are secure (as secure as it gets with untampered devices).</p>

<pre><code class="language-ts">import { set } from "@op-engineering/op-s2";
import { generateSecureRandom } from "react-native-securerandom";

async function generateKey() {
  // generate secure bytes using the t2 chip (SecRandomCopyBytes) and Secure Random on Android
  const secureBytes = await generateSecureRandom(42);

  // on the latest versions of RN btoa is part of hermes
  const key = btoa(String.fromCharCode.apply(null, secureBytes));

  const { error } = set({
    key: "myKey",
    value: key,
    withBiometrics: true, // This means a FaceID/biometrics prompt will appear every time. See the docs if you don't want to use this
  });
}
</code></pre>

<p><code>withBiometrics</code> is the safest but most cumbersome option, as it requires user authentication every time you want to read this key. You can leave it out, and it will still be secure. How are these packages secure? Because KeyStore/Keychain actually allow access on a per-app bundle basis (with signature verification, I believe). You only have access to the data you have created; you cannot read values from other apps/processes. So, at least we have per-app security.</p>

<p>Then, when you start your storage, you can pass this key:</p>

<pre><code class="language-ts">const myKey = get({ key: "myKey", withBiometrics: true });

const storage = MyStateLibrary.create({
  encryptionKey: myKey,
});

const myKey = null;
// You can even trigger garbage collection to make a timed attack even harder
</code></pre>

<p>Again, nothing is truly secure, but at least we have an extra layer of protection. Clearing the memory is also a best practice to prevent leaks. We then rely on the library to have correctly implemented an encryption algorithm.</p>

<blockquote>
  <p>As a funny side note:
Apple’s Keychain is just an API wrapper against a SQLite database that has some OS protections bolted in.
Keystore is just an API for retrieving/generating/saving secure crypto keys. The actual API that saves data is EncryptedSharedPreferences, which just saves files to disk with encryption bolted on.</p>

  <p>:)</p>
</blockquote>

<h2 id="use-secure-storage">Use Secure Storage</h2>

<p>Once you have your encryption keys securely stored, it’s time to move on to storing the data itself securely. Here, some libraries are already prepared for that. MMKV allows you to specify an encryption key:</p>

<pre><code class="language-ts">import { get } from "@op-engineering/op-s2";
import { MMKV, Mode } from "react-native-mmkv";

const myKey = get({ key: "myKey", withBiometrics: true });

export const storage = new MMKV({
  id: `user-${userId}-storage`,
  path: `${USER_DIRECTORY}/storage`,
  encryptionKey: myKey,
  mode: Mode.MULTI_PROCESS,
});
</code></pre>

<p>Another alternative is using an encrypted fork of SQLite called SQLCipher, which you can use via <a href="https://github.com/OP-Engineering/op-sqlite">op-sqlite</a>. You just need to enable SQLCipher support in the <code>package.json</code>:</p>

<pre><code class="language-json">"op-sqlite": {
  "sqlcipher": true
}
</code></pre>

<p>Then, when you open your database:</p>

<pre><code class="language-ts">const { open } from '@op-engineering/op-sqlite';

const myKey = get({ key: "myKey", withBiometrics: true });

const db = open({
  name: 'my_secure_db.sqlite',
  encryptionKey: myKey
});
</code></pre>

<p>This will fully encrypt the data stored on disk with a bit of overhead. As long as your encryption key is not compromised, it should be safe.</p>

<h1 id="hardware-keys">Hardware Keys</h1>

<p>I have to mention hardware keys, which circumvent the issue of the attacker having remote access to the device. Since they are separate from the OS, they cannot be easily compromised (apart from being physically stolen) and provide an extra layer of security.</p>

<p>If your app requires an even higher level of security, it might be worth looking into them. I have bridged the Yubico SDK for RN, but it’s not currently open source. <a href="https://developers.yubico.com/Developer_Program/Guides/User_Loaded_Data.html">Although you cannot save data to a YubiKey</a>, authentication would be enough to use secure bytes as an encryption key. As I’ve shown in this article, as long as the encryption key is safe, you can consider your data safe enough. If someone is willing to sponsor the work, I would be willing to create a Turbo module to make this functionality available to React Native apps.</p>

<h1 id="encryption-algorithms">Encryption algorithms</h1>

<p>If you are on the market for rolling your own encryption or need some crypto math, just use <a href="https://github.com/margelo/react-native-quick-crypto">react-native-quick-crypto</a>, it’s a (re)implementation of the <a href="https://nodejs.org/api/crypto.html">node’s crypto module</a>. There are many people who are not fans of the API, doesn’t matter. It’s proven and fast since it uses C++ bindings. It’s also somewhat incomplete but more APIs can be added if you are willing to sponsor the work.</p>

<h1 id="conclusion">Conclusion</h1>

<p>It’s still worth looking into the <a href="https://reactnative.dev/docs/security#storing-sensitive-info">official RN documentation</a>; however, I hope this guide is a bit more hands-on.</p>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[Like any other software development framework, security should be a top priority when developing React Native applications. However, there are a lot of misconceptions, fueled by the existence of packages and the lack of targeted information.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ospfranco.com/assets/oscar.jpg" /><media:content medium="image" url="https://ospfranco.com/assets/oscar.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Rust modules in React Native</title><link href="https://ospfranco.com/post/2024/05/08/react-native-rust-module-guide/" rel="alternate" type="text/html" title="Rust modules in React Native" /><published>2024-05-08T15:00:00+02:00</published><updated>2024-05-08T15:00:00+02:00</updated><id>https://ospfranco.com/post/2024/05/08/react%20native%20rust%20module%20guide</id><content type="html" xml:base="https://ospfranco.com/post/2024/05/08/react-native-rust-module-guide/"><![CDATA[<p>This is a tutorial on how I integrate Rust modules, but in the video form I go over the concepts that actually make this work, so you can adjust and understand the tooling behind and you can maintain your integration.</p>

<iframe class="w-full h-96" src="https://www.youtube.com/embed/PPU4Hrz4J_s" title="YouTube video player" frameborder="0" allow="accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>

<h1 id="basic-setup">Basic Setup</h1>

<ul>
  <li>Set up Rust compiler on your computer, just follow the instructions on the Rust website (use <code>rustup</code>, brew will give you headaches).</li>
  <li>In order to compile the Android version you are going to use the <code>ndk</code> create which simplifies the command to compile the rust library for Android. Install it via <code>cargo install ndk</code></li>
  <li>
    <p>Create a crate where we will put all of our Rust lib code and infra scripts. In my case I will call it <code>my_sdk</code></p>

    <pre><code class="language-bash">cargo new my_sdk
</code></pre>
  </li>
  <li>
    <p>Create a <code>rust-toolchain.toml</code> in the project folder you just created. This will add all the necessary architectures to compile your project:</p>

    <pre><code class="language-toml">[toolchain]
channel = "stable"
targets = ["x86_64-apple-ios", "aarch64-apple-ios", "aarch64-apple-ios-sim", "aarch64-linux-android", "armv7-linux-androideabi", "x86_64-linux-android", "i686-linux-android"]
</code></pre>
  </li>
  <li>Change name of <code>main.rs</code> to <code>lib.rs</code></li>
  <li>
    <p>Add your API code on lib.rs</p>

    <pre><code class="language-rust">#[no_mangle]
extern "C" fn sum(a: i32, b: i32) {
  a + b
}
</code></pre>
  </li>
  <li>
    <p>We will use a crate called <code>cbindgen</code> that will help us generate a C header for our Rust functions. We will automate the header creation by creating a <code>build.rs</code> that runs every time our project is compiled/checked. First we are going to add the dependency as a <code>[build-dependencies]</code>, the project <code>Cargo.toml</code>:</p>

    <pre><code class="language-toml">[build-dependencies]
cbindgen = "0.26.0"
</code></pre>
  </li>
  <li>
    <p>Then on the root of the project create a <code>build.rs</code> file:</p>

    <pre><code class="language-rust">extern crate cbindgen;

use std::env;

fn generate_c_headers() {
    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();

    cbindgen::Builder::new()
        .with_crate(crate_dir)
        .with_language(cbindgen::Language::C)
        .with_include_guard("my_sdk_h")
        .with_autogen_warning(
            "/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */",
        )
        .with_namespace("my_sdk")
        .with_cpp_compat(true)
        .generate()
        .expect("Unable to generate bindings")
        .write_to_file("generated/include/my_sdk.h");
}

fn main() {
    // Tell Cargo that if the given file changes, to rerun this build script.
    println!("cargo:rerun-if-changed=src/lib.rs");
    generate_c_headers();
}
</code></pre>
  </li>
  <li>
    <p>Modify the <code>cargo.toml</code> to compile as static library. You can also create a dynamic library that can be loaded on runtime on Android, but both should work. The <code>jni</code> dependency is only necessary if you are planing to call your code from Java/Kotlin.</p>

    <pre><code class="language-toml">[package]
name = "SDK"
version = "0.1.0"
edition = "2021"

[lib]
name = "SDK"
crate-type = ["staticlib"]

[dependencies]
libc = "0.2.80" # Allows to use c types CString, c_char, etc.
jni = "0.17.0" # OPTIONAL Allows to write JNI bindings directly from Rust

[build-dependencies]
cbindgen = "0.26.0"
</code></pre>
  </li>
  <li>(Optional) In my experience static binaries on iOS are OK, but on Android they can be huge. Ideally you would specify <code>crate-type = ['staticlib', 'dylib']</code> and just be on your merry way, however, it seems this bloats the static lib massively. In order to get a static binary for iOS and a dynamic one for Android you can set <code>crate-type = ['dylib']</code> and change the compilation command for iOS to <code>cargo rustc --crate-type=staticlib ...</code></li>
</ul>

<h1 id="ios">iOS</h1>

<ul>
  <li>
    <p>We are going to use <code>Make</code> to compile and package the library. No specific reason for it you can create your script on JS too.</p>

    <pre><code class="language-make">ARCHS_IOS = x86_64-apple-ios aarch64-apple-ios aarch64-apple-ios-sim
ARCHS_ANDROID = aarch64-linux-android armv7-linux-androideabi x86_64-linux-android i686-linux-android
LIB = libmy_sdk.a
DYLIB = libmy_sdk.so
XCFRAMEWORK = my_sdk.xcframework

all: ios android

ios: $(XCFRAMEWORK)

android: $(ARCHS_ANDROID)
  # After build is done copy files into the android folder
  mkdir -p ../android/app/src/main/jniLibs
  mkdir -p ../android/app/src/main/jniLibs/x86
  mkdir -p ../android/app/src/main/jniLibs/arm64-v8a
  mkdir -p ../android/app/src/main/jniLibs/armeabi-v7a
  mkdir -p ../android/app/src/main/jniLibs/x86_64


  cp ./target/i686-linux-android/release/$(DYLIB) ../android/app/src/main/jniLibs/x86/$(DYLIB)
  cp ./target/aarch64-linux-android/release/$(DYLIB) ../android/app/src/main/jniLibs/arm64-v8a/$(DYLIB)
  cp ./target/arm-linux-androideabi/release/$(DYLIB) ../android/app/src/main/jniLibs/armeabi-v7a/$(DYLIB)
  cp ./target/x86_64-linux-android/release/$(DYLIB) ../android/app/src/main/jniLibs/x86_64/$(DYLIB)

.PHONY: $(ARCHS_IOS)
$(ARCHS_IOS): %:
  cargo build --target $@ --release

.PHONY: $(ARCHS_ANDROID)
$(ARCHS_ANDROID): %:
  cargo ndk --target $@ --platform 31 --release

$(XCFRAMEWORK): $(ARCHS_IOS)
  mkdir -p simulator_fat
  lipo -create target/x86_64-apple-ios/release/$(LIB) target/aarch64-apple-ios-sim/release/$(LIB) -output simulator_fat/$(LIB)
  xcodebuild -create-xcframework -library target/aarch64-apple-ios/release/$(LIB) -headers include -library simulator_fat/$(LIB) -headers include -output $@
  cp -r $@ ../ios/$@
</code></pre>

    <blockquote>
      <p>You see on iOS we are creating a xcframework, that is because the architectures conflict (iOS and iOS sim m1), so we use a xcframework to package it nicely for Xcode to build our app.</p>
    </blockquote>
  </li>
  <li>The <code>copy-ios.sh</code> is just a simple scripts that copies the generated xcframework to a more convenient location. You can leave it out if you modify the locations manually.</li>
  <li>Add generated <code>.xcframework</code> to Xcode
    <ul>
      <li>If you are doing this on a single project then dragging and dropping is the easiest, just make sure in the project properties mark the xcframework as embed and sign.</li>
      <li>If you are doing this on React Native, as part of a library, then you need to modify your podspec. Just drop the <code>xcframework</code> somewhere and then on your podspec add <code>s.vendored_frameworks = "my_sdk.xcframework"</code></li>
    </ul>
  </li>
  <li>You should now be able to simply import the header file (<code>#include "my_sdk.h"</code>) and call any Rust function from any Obj-C++ file</li>
</ul>

<h1 id="binary-size">Binary size</h1>

<p>As mentioned in a previous point, the sizes of compiled Rust binaries can be quite large. Which is a problem when targeting mobile platforms. You need to turn on optimizations to get the binary size down, check out the <a href="https://ospfranco.com/rust-reduce-binary-size/">size optimization guide</a>.</p>

<h1 id="android">Android</h1>

<ul>
  <li>
    <p>The <code>ndk</code> crate simplifies the generation of Android Rust modules massively. You need to have the variables set up properly though. Make sure you have the Android NDK properly installed in your system. Then set the following environment variables in your system. Change the NDK version to whatever you have installed or you need:</p>

    <pre><code class="language-bash">export ANDROID_SDK_ROOT=$HOME/Library/Android/sdk
export ANDROID_HOME=$HOME/Library/Android/sdk
export ANDROID_NDK_HOME=$ANDROID_HOME/ndk/25.1.8937393
</code></pre>
  </li>
  <li>
    <p>We need to tell cmake to link the library when compiling our native module, on the <code>CMakeLists.txt</code> file add the following:</p>

    <pre><code class="language-make">make_path(SET MY_SDK_LIB ${CMAKE_CURRENT_SOURCE_DIR}/jniLibs/${ANDROID_ABI}/libmy_sdk.a NORMALIZE)
add_library(my_sdk STATIC IMPORTED)
set_target_properties(my_sdk PROPERTIES IMPORTED_LOCATION ${MY_SDK_LIB})

target_link_libraries(tm
        jsi
        my_sdk
        react_nativemodule_core
        react_codegen_AppSpecs
)
</code></pre>
  </li>
  <li>We will still not be able to call our Rust code from Java, because we need to go through the JNI and the JNI is very picky regarding names, we need to create specific binding for Android, on the <code>lib.rs</code> and the following block</li>
  <li>We can finally call <code>make android</code> and the library will be created for us</li>
  <li>
    <p><strong>Optional</strong> If you want to call the functions from Java/Kotlin (and not from C++) you need to create another binding using Android’s JNI:</p>

    <pre><code class="language-rust">// On Android function names need to follow the JNI convention
pub mod android {
  extern crate jni;

  use self::jni::JNIEnv;
  use self::jni::objects::JClass;
  use self::jni::sys::jstring;

  #[no_mangle]
  pub unsafe extern fn Java_com_samplesdk_BindingsModule_helloWorld(env: JNIEnv, _: JClass) -&gt; jstring {
    let output = env.new_string("Hello from Rust!").expect("Couldn't create java string!");
    output.into_inner()
  }
}
</code></pre>
  </li>
  <li>
    <p>We can now create a RN Module (or JSI module) and simply load the library and call it (via JNI of course)</p>

    <pre><code class="language-java">package com.samplesdk;

import com.facebook.react.bridge.NativeModule;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;
import com.facebook.react.util.RNLog;
import java.util.Map;
import java.util.HashMap;

public class BindingsModule extends ReactContextBaseJavaModule {


    BindingsModule(ReactApplicationContext context) {
        super(context);
        // If you are using a Android dylib, you will have to load it now!
    }

    @Override
    public String getName() {
        return "Bindings";
    }

    @ReactMethod
    public void init(String apiKey) {
        RNLog.w(this.getReactApplicationContext(), "BindingsModule.init() called with apiKey: " + apiKey + "calling rust");
        String result = helloWorld();
        RNLog.w(this.getReactApplicationContext(), "Rust says: " + result);
    }

    private static native String helloWorld();
}
</code></pre>
  </li>
</ul>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[This is a tutorial on how I integrate Rust modules, but in the video form I go over the concepts that actually make this work, so you can adjust and understand the tooling behind and you can maintain your integration.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ospfranco.com/assets/oscar.jpg" /><media:content medium="image" url="https://ospfranco.com/assets/oscar.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Why I believe Swift is better than Rust</title><link href="https://ospfranco.com/why-I-believe-swift-is-better-than-rust/" rel="alternate" type="text/html" title="Why I believe Swift is better than Rust" /><published>2024-04-29T00:00:00+02:00</published><updated>2024-04-29T00:00:00+02:00</updated><id>https://ospfranco.com/why%20I%20believe%20swift%20is%20better%20than%20rust</id><content type="html" xml:base="https://ospfranco.com/why-I-believe-swift-is-better-than-rust/"><![CDATA[<p>Over the last year, I have been building software in native languages. C++, Swift, Kotlin and most recently Rust. Rust has been particularly tricky to get right and has given me an uneasy feeling.</p>

<h1 id="solving-memory-management">Solving memory management</h1>

<p>The big promise of Rust is to prevent memory allocation problems. It does this via the Borrow Checker which forces you to avoid leaky patterns from the get-go. The problem is that the borrow checker forces you to write manually safe code ALL THE TIME. Some of my thoughts are expressed at length in this recent <a href="https://loglog.games/blog/leaving-rust-gamedev/#rust-being-great-at-big-refactorings-solves-a-largely-self-inflicted-issues-with-the-borrow-checker">Rust article</a> that is making the rounds on the internet:</p>

<blockquote>
  <p>The most fundamental issue is that the borrow checker forces a refactor at the most inconvenient times. Rust users consider this to be a positive, because it makes them “write good code”, but the more time I spend with the language the more I doubt how much of this is true. Good code is written by iterating on an idea and trying things out, and while the borrow checker can force more iterations, that does not mean that this is a desirable way to write code. I’ve often found that being unable to just move on for now and solve my problem and fix it later was what was truly hurting my ability to write good code.</p>
</blockquote>

<p>While the specific use-case of writing Rust games may not be ideal for such a strict system as the borrow-checker I have found the tyrannical nature of it more cumbersome than helpful. On my normal day-to-day, there are very few pieces of code where I want to write the memory-safe code myself. Opening a file, and passing a variable to multiple functions, everything becomes 20x cumbersome.</p>

<p>The borrow-checker on a high level, dumps the responsibility of writing safe code to YOU. It’s a very useful helper but it just points at the correct path and doesn’t solve the problem <strong>for you</strong>.</p>

<h1 id="swift-has-become-my-favorite-language">Swift has become my favorite language</h1>

<p>After the last few years, I can only praise Swift. It’s not perfect, but it feels like the culmination of the C-like family of languages. It does a lot of the nice things Rust does. Explicit control, and exhaustive checks for branching code, yet it has dynamic syntax. But it also does them with automatic memory management.</p>

<p>Swift has taken all the lessons of the last 20 years of software development and dumped them into a useful language.</p>

<h1 id="the-feeling">The feeling</h1>

<p>Whenever I open a Swift file I wrote myself I can immediately pick up where I left. Whereas with Rust every function is a mess of <code>unwrap</code>, <code>clone</code>, <code>arc</code>, <code>box</code>. Ultimately, Rust solved the memory management problem at the interface between your hands and the keyboard and that makes coding too hard.</p>

<p>I don’t think Swift is perfect but is a joy to work with.</p>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[Over the last year, I have been building software in native languages. C++, Swift, Kotlin and most recently Rust. Rust has been particularly tricky to get right and has given me an uneasy feeling.]]></summary></entry><entry><title type="html">How to resolve duplicated libraries on Android</title><link href="https://ospfranco.com/how-to-resolve-duplicated-libraries-on-android/" rel="alternate" type="text/html" title="How to resolve duplicated libraries on Android" /><published>2023-12-07T00:00:00+01:00</published><updated>2023-12-07T00:00:00+01:00</updated><id>https://ospfranco.com/how%20to%20resolve%20duplicated%20libraries%20on%20android</id><content type="html" xml:base="https://ospfranco.com/how-to-resolve-duplicated-libraries-on-android/"><![CDATA[<p>If you have developed on Android long enough, you might have found an error like this:</p>

<pre><code class="language-sh">A failure occurred while executing com.android.build.gradle.internal.tasks.MergeNativeLibsTask$MergeNativeLibsTaskWorkAction
2 files found with path 'lib/arm64-v8a/libcrypto.so'
</code></pre>

<p>This is caused by two libraries/dependencies generating the same artifact (in this case, depending on OpenSSL which generates <code>libcrypto.so</code>). If you haven’t declared your dependency on OpenSSL, then the problem is a transitive dependency (you require A and B, and both require C).</p>

<p>There are a number of workarounds, but they all have potential issues, so here are some short explanations.</p>

<h1 id="exclude">Exclude</h1>

<p>The first solution you might try is the <code>exclude</code> command of gradle. This will only work if you are modifying the sources of one of the conflicting libraries. This basically tells Gradle: whenever you are packaging this library, exclude this files from the final bundle merge.</p>

<pre><code class="language-groovy">packagingOptions {
      excludes = [
        // ... other excluded files
        "**/libcrypto.so"
      ]
}
</code></pre>

<p>This will basically force your final application to contain one <code>libcrypto.so</code> and avoid any potential conflicts. The problem is than, if you remove the other dependency and no one is left to generate the .so, then you are out of luck and you will get an error saying the file is missing.</p>

<h1 id="pick-first">Pick first</h1>

<p>Another possible strategy is using <code>pickFirst</code>, it basically tells Gradle: “whatever you find first, just link against that”. The problem with this however is that it cannot be included in the offending library <code>build.gradle</code> but must be specified in the application’s <code>build.gradle</code> (since that is the parent scope that faces the conflict when compiling the dependencies)</p>

<pre><code class="language-groovy">packagingOptions {
  pickFirst '**/libcrypto.so'
}
</code></pre>

<h1 id="other-strategies">Other strategies</h1>

<p>There are other strategies that work on pure gradle dependencies, which might or might not work on React Native but you can give them a try.</p>

<h2 id="excluding-group">Excluding group</h2>

<p>Change the declared dependency to exclude the internal dependency</p>

<pre><code class="language-groovy">implementation ('junit:junit:4.12'){
    exclude group: 'org.hamcrest', module:'hamcrest-core' // exclude the transtive dependency
}
</code></pre>

<h2 id="explicitely-requiring-the-dependency">Explicitely requiring the dependency</h2>

<pre><code class="language-groovy">implementation 'junit:junit:4.12'
implementation 'org.hamcrest:hamcrest-core:1.3' // force the shared dependency version
</code></pre>

<h2 id="force-resolution">Force resolution</h2>

<p>This might force an older version into the dependencies</p>

<pre><code class="language-groovy">android {
    configurations.all {
        resolutionStrategy.force 'org.hamcrest:hamcrest-core:1.1'
    }
}
</code></pre>

<h1 id="version-missmatch">Version missmatch</h1>

<p>The problem with this solutions is that you are forcing a single version upon your dependencies, which might break because they might rely on the API of a particular version. I don’t know how to include two versions of the same library unfortunately, so the actual solution is to make sure you are on the latest versions and they all depend on the same transitive dependency version.</p>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[If you have developed on Android long enough, you might have found an error like this:]]></summary></entry><entry><title type="html">Swift 5.9 Notes</title><link href="https://ospfranco.com/swift-5.9-notes/" rel="alternate" type="text/html" title="Swift 5.9 Notes" /><published>2023-11-24T00:00:00+01:00</published><updated>2023-11-24T00:00:00+01:00</updated><id>https://ospfranco.com/swift%205.9%20notes</id><content type="html" xml:base="https://ospfranco.com/swift-5.9-notes/"><![CDATA[<p>Swift 5.9 has enabled direct interop with C++. This means you can directly call and interact with C++, as well as introduced a series of objects that allow to interact with integral and C++ class values directly (e.g. <code>std::string</code>).</p>

<p>In order to enable the C++ interop, you need to be on XCode 15 (I think), and your projects needs to be Swift enabled. If you are not sure, you only need to add a Swift file and the bridging header will be created for you and all the Swift build settings will be enabled on XCode.</p>

<p>Afterwards you need to go into the <code>Build Settings</code> → <code>Swift Compiler - Language</code> → <code>C++ and Obj-C++ Interoperability</code> and change the value from C to C++</p>

<p>If you want to do the same in a CocoaPods project you need to modify the pod config like this:</p>

<pre><code class="language-ruby">s.pod_target_xcconfig = {
  'SWIFT_OBJC_INTEROP_MODE' = 'objcxx'
}
</code></pre>

<p>Clang has issues with headers (it generates a module map, topic for another day). Instead of importing headers directly from your dependency, you should import the umbrella header.</p>

<pre><code class="language-C++">#import &lt;jsi/jsi.h&gt;
</code></pre>

<p>You should import everything with</p>

<pre><code class="language-C++">#import &lt;mypod-umbrella.h&gt;
</code></pre>

<p>Afterwards you are in the clear, you should be able to call any C++ function/class from your Swift code and viceversa.</p>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[Swift 5.9 has enabled direct interop with C++. This means you can directly call and interact with C++, as well as introduced a series of objects that allow to interact with integral and C++ class values directly (e.g. std::string).]]></summary></entry><entry><title type="html">Mix C++, Obj-C and Swift files in a single XCode target</title><link href="https://ospfranco.com/post/2023/11/24/mix-c++,-obj-c-and-swift-files-in-a-single-xcode-target/" rel="alternate" type="text/html" title="Mix C++, Obj-C and Swift files in a single XCode target" /><published>2023-11-24T00:00:00+01:00</published><updated>2023-11-24T00:00:00+01:00</updated><id>https://ospfranco.com/post/2023/11/24/mix%20c++,%20obj-c%20and%20swift%20files%20in%20a%20single%20xcode%20target</id><content type="html" xml:base="https://ospfranco.com/post/2023/11/24/mix-c++,-obj-c-and-swift-files-in-a-single-xcode-target/"><![CDATA[<p>If you have an XCode project where you are trying to mix C++, Obj-C and Swift, things will not work. If you only deal with Obj-C++ everything compiles fine, but the moment you add Swift into the mix you might start getting a slew of errors on your header files.</p>

<p>The root issue is the <a href="https://stackoverflow.com/questions/47788422/cannot-use-namespace-and-cannot-include-standard-c-library-in-my-h-files">Swift compiler</a>, it doesn’t support C++, yet it still tries to compile C headers on its own. Whenever you have Swift files together with C++ files, it’s the Swift compiler that will kick-in in a first pass (followed by CLang? maybe before? doesn’t matter) and will try to compile the headers as C headers independently of what you tell it, file extensions, etc.</p>

<p>You will then start getting errors based on the C++ syntax (if you used any). For example if you are using namespaces (which don’t exist on C), you will get <a href="https://github.com/CocoaPods/CocoaPods/issues/12105#issuecomment-1824455557">invalid syntax errors</a>.</p>

<p>There are a couple workarounds. First you can wrap every single bit of C++ syntax in your headers around a macro that checks if the compiler supports C++:</p>

<pre><code class="language-C++">#if defined __cplusplus
extern "C" {
#endif

#if defiend __cplusplus

class Foo
{
    void bar(int c);
}
#endif
struct FooHandle;

void Foo_bar(struct FooHandle* foo, int c);

#if defined __cplusplus
}
#endif
</code></pre>

<p>Every header you create you will have to manually modify to check for syntax errors.</p>

<h1 id="cocoapods">Cocoapods</h1>

<p>Cocoapods has a special problem with this, since it generates an umbrella header that will also get compiled by the Swift compiler and it will fail. Either of the methods described above will workaround the issue for now.</p>

<p>Another alternative is to hide the header files from the XCode file system, yet still provide them via flags that will get passed to the compilers:</p>

<pre><code class="language-ruby">require "json"

package = JSON.parse(File.read(File.join(__dir__, "package.json")))

Pod::Spec.new do |s|
  s.name           = "matrix"
  s.version        = package["version"]
  s.summary        = package["description"]
  s.homepage       = package["homepage"]
  s.license        = package["license"]
  s.authors        = package["author"]
  s.platforms      = { :ios =&gt; "13.0" }

  s.pod_target_xcconfig = {
    "DEFINES_MODULE" =&gt; "YES",
    "SWIFT_COMPILATION_MODE" =&gt; "wholemodule",
    "CLANG_CXX_LANGUAGE_STANDARD" =&gt; "c++17",
    # ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
    "HEADER_SEARCH_PATHS" =&gt; "\"$(PODS_TARGET_SRCROOT)/cpp/\"/** " # This will link the headers at compile time, flag passed directly to the compiler
  }

  # ↓↓↓↓↓↓↓↓↓↓↓↓
  s.source_files = "ios/**/*.{mm,swift}", "cpp/**/*.{cpp,c}" # Do not include the headers in the sources, then XCode won't try to compile them

  # ↓↓↓↓↓↓↓↓↓↓↓↓↓↓
  s.preserve_paths = [
    "cpp/**/*.h",
    "ios/**/*.h"
  ]

  s.dependency "React"
  s.dependency "React-Core"
  s.dependency "React-callinvoker"
end
</code></pre>

<p>One side effect is that the headers will not appear on the project explorer view on XCode, which is annoying if you are developing something from scratch, you can still ⌘ + click to open it, but it won’t show navigation side bar.</p>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[If you have an XCode project where you are trying to mix C++, Obj-C and Swift, things will not work. If you only deal with Obj-C++ everything compiles fine, but the moment you add Swift into the mix you might start getting a slew of errors on your header files.]]></summary></entry><entry><title type="html">Get iOS simulator local home folder on macOS</title><link href="https://ospfranco.com/post/2023/11/13/get-ios-simulator-local-home-folder-on-macos/" rel="alternate" type="text/html" title="Get iOS simulator local home folder on macOS" /><published>2023-11-13T00:00:00+01:00</published><updated>2023-11-13T00:00:00+01:00</updated><id>https://ospfranco.com/post/2023/11/13/get%20ios%20simulator%20local%20home%20folder%20on%20macos</id><content type="html" xml:base="https://ospfranco.com/post/2023/11/13/get-ios-simulator-local-home-folder-on-macos/"><![CDATA[<p>Sometimes you want to really see what is on the file system of iOS. Even the simulator file system is useful to check if files are correctly downloaded or sometimes you might want to check a database file manually.</p>

<p>You can easily get the directory printed out from the XCode console. When you application is paused or a debugger breakpoint is hit, you can type <code>po NSHomeDirectory()</code> and it will print out the local directory.</p>

<p><img src="https://ospfranco.com/assets/pohomedirectory.png" alt="home directory print out" title="PO NSHomeDirectory" /></p>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[Sometimes you want to really see what is on the file system of iOS. Even the simulator file system is useful to check if files are correctly downloaded or sometimes you might want to check a database file manually.]]></summary></entry></feed>