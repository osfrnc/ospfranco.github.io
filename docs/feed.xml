<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://ospfranco.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://ospfranco.com/" rel="alternate" type="text/html" /><updated>2024-06-23T09:29:33+02:00</updated><id>https://ospfranco.com/feed.xml</id><title type="html">Oscar Franco</title><author><name>Oscar Franco</name></author><entry><title type="html">Reduce Rust binaries size</title><link href="https://ospfranco.com/rust-reduce-binary-size/" rel="alternate" type="text/html" title="Reduce Rust binaries size" /><published>2024-06-23T00:00:00+02:00</published><updated>2024-06-23T00:00:00+02:00</updated><id>https://ospfranco.com/rust%20reduce%20binary%20size</id><content type="html" xml:base="https://ospfranco.com/rust-reduce-binary-size/"><![CDATA[<p>I find myself writing a lot of Rust nowadays. I’m by no means an expert, but I need to make do with my limited knowledge. A constant problem I’m facing is that the binaries outputted by Rust are huge. This is especially a problem on mobile, where each megabyte counts.</p>

<p>The documentation is a bit confusing, but here is the configuration I ended up using to get somewhat OK sizes. In the <code>cargo.toml</code> file:</p>

<pre><code class="language-toml">[profile.release] # When compiling in release mode
debug = false # Exclude debug symbols
strip = "symbols" # Exclude the rest of the symbols
# opt-level = "z" # Did not use this, but it equals C++'s optimize for size (O3?)
lto = true # Link time optimization, not sure what this does but it helps reduce the size
</code></pre>

<p>Additionally, using the following flag turns on dead-code stripping:</p>

<pre><code>RUSTFLAGS="-C link-arg=-Wl,-dead_strip" cargo build --release --target=&lt;your-target&gt;
</code></pre>

<h1 id="cargo-bloat">Cargo Bloat</h1>

<p>I haven’t fully explored what this tool can do, but it does point to large sections of the code. Install it with <code>cargo install cargo-bloat</code> and then run:</p>

<pre><code>cargo bloat --release --target=&lt;your-target&gt;
</code></pre>

<h1 id="results">Results</h1>

<p>Using all the compile optimizations, I was able to reduce the output binary from 60 MB to 30 MB. It’s still large but better.</p>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[I find myself writing a lot of Rust nowadays. I’m by no means an expert, but I need to make do with my limited knowledge. A constant problem I’m facing is that the binaries outputted by Rust are huge. This is especially a problem on mobile, where each megabyte counts.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ospfranco.com/assets/oscar.jpg" /><media:content medium="image" url="https://ospfranco.com/assets/oscar.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Writting tests for Tauri Rust Commands</title><link href="https://ospfranco.com/writting-tests-for-tauri-rust-commands/" rel="alternate" type="text/html" title="Writting tests for Tauri Rust Commands" /><published>2024-06-05T00:00:00+02:00</published><updated>2024-06-05T00:00:00+02:00</updated><id>https://ospfranco.com/writting%20tests%20for%20tauri%20rust%20commands</id><content type="html" xml:base="https://ospfranco.com/writting-tests-for-tauri-rust-commands/"><![CDATA[<p>I’m now in charge of a Tauri app and there is a lot of native Rust functionality that needs to be exposed to the JS side. Like any principled dev I want to write tests for my code.</p>

<p>The official documentation says one should write e2e tests with a UI simulation framework to test this functionality but that is way to cumbersome. I wanted unit tests for my Rust code. Also, I did not have stateless Rust functions, but functions where Tauri itself managed the state, so I needed to mock the entire Tauri app stack.</p>

<p>Credit where is due this <a href="https://stackoverflow.com/questions/77524788/writing-tests-for-tauri-commands-how-to-access-and-manage-state-in-test-environ">Stack Overflow answer</a> provided the info I was looking for.</p>

<p>However Tauri <code>1.6.7</code> broke this functionality and <code>1.6.8</code> fixed it by adding a new parameter.</p>

<p>Without further ado, first you need to add the <code>test</code> feature in your Tauri dependency:</p>

<pre><code class="language-toml">tauri = { version = "1.6.8", features = ["api-all", "updater", "test"] }
</code></pre>

<p>Then you can write your test like so:</p>

<pre><code class="language-rust">#[cfg(test)]
mod tests {
    use super::*;
    use tauri::{
        test::{mock_context, noop_assets, MockRuntime},
        App,
    };

    fn before_each() -&gt; Result&lt;tauri::App&lt;MockRuntime&gt;, std::io::Error&gt; {
        let app = tauri::test::mock_builder()
            .plugin(super::init_plugin())
            .build(mock_context(noop_assets()))
            .unwrap();

        // Any other setup code you need
        Ok(app)
    }

    async fn after_each(app: App&lt;MockRuntime&gt;) {
        // your clean up code
    }

    #[tokio::test]
    async fn should_return_0_with_no_loaded_models() {
        let app = before_each().unwrap();
        let window = app.get_window("main").unwrap();
        let foo = tauri::test::get_ipc_response::&lt;Vec&lt;String&gt;&gt;(
            &amp;window,
            tauri::InvokePayload {
                cmd: "plugin:my_plugin|foo".into(),
                tauri_module: None,
                invoke_key: Some(tauri::test::INVOKE_KEY.into()),
                callback: tauri::api::ipc::CallbackFn(0),
                error: tauri::api::ipc::CallbackFn(1),
                inner: serde_json::json!({}),
            },
        );

        assert!(foo.is_ok());

        after_each(app).await;
    }

}

</code></pre>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[I’m now in charge of a Tauri app and there is a lot of native Rust functionality that needs to be exposed to the JS side. Like any principled dev I want to write tests for my code.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ospfranco.com/assets/oscar.jpg" /><media:content medium="image" url="https://ospfranco.com/assets/oscar.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">React Native Security Guide</title><link href="https://ospfranco.com/react-native-security-guide/" rel="alternate" type="text/html" title="React Native Security Guide" /><published>2024-05-30T00:00:00+02:00</published><updated>2024-05-30T00:00:00+02:00</updated><id>https://ospfranco.com/react%20native%20security%20guide</id><content type="html" xml:base="https://ospfranco.com/react-native-security-guide/"><![CDATA[<p>Like any other software development framework, security should be a top priority when developing React Native applications. However, there are a lot of misconceptions, fueled by the existence of packages and the lack of targeted information.</p>

<p>In this guide, we will explore various security considerations and best practices that every React Native developer should be aware of. If you find anything incorrect or have feedback, please reach out! This is a topic we should all care about.</p>

<h1 id="preface">Preface</h1>

<p>Let’s address this upfront: there is no real way to protect data once it is on the device. A motivated attacker with root or hardware access to the device will eventually be able to bypass security features when storing on-device data. Here is a <a href="https://blog.1password.com/local-threats-device-protections/">1Password write-up</a> that explains this well.</p>

<p>As we are not all building vault apps, this should be our guiding principle: <strong>do not put anything on the user’s device that you cannot afford to leak</strong>.</p>

<p>But that doesn’t mean all is lost. If the attacker does not have direct access to the machine, applying protections will still be a sufficient deterrent (and secure enough unless they actually get hold of the hardware). Using the best-known security practices can make some attacks so cumbersome that they act as a deterrent, so we should still use them.</p>

<h1 id="secrets">Secrets</h1>

<p>Armed with this knowledge, there is one inconvenient truth: <strong>you won’t be able to protect secrets like API keys for third-party services</strong>. No matter how you store or obfuscate them, or what packages promise. You also won’t be able to protect your encryption keys, which means <strong>you won’t be able to protect the encrypted user data</strong> (again, if the hardware is compromised). The difference lies in the fact that user data belongs to the user; they can hack their own app/device and see their data, but they had access to this data anyway. The problematic part is the secrets, as they are shared among your users.</p>

<p>Is there a way to protect secrets? Using a gateway would be one way, but sometimes it is not possible, for example, when using a third-party SDK that ingests the key directly. There is nothing we can do about that.</p>

<p>An important thing to note here is the existence of device attestation. Device attestation is a process where the OS tries to verify that the device and/or app has not been tampered with. There are <a href="https://support.apple.com/guide/deployment/managed-device-attestation-dep28afbde6a/web">APIs for iOS</a> and <a href="https://developer.android.com/privacy-and-security/safetynet/attestation">Android</a>. Some companies offer this as a service with an SDK, allowing you to verify the device/app before sending data to it. However, this is a not very well-explored topic and may be time-consuming or expensive.</p>

<p>With device attestation, you could have a more secure (read: more inconvenient to hack) secret management:</p>

<ol>
  <li>On app start, perform device attestation. If it fails: game over, you tampered with the device/app, so no access.</li>
  <li>On first start, download the secrets and store them in your favorite cryptographically secure storage.</li>
  <li>Combine this with partial keys that need to be fetched from a server each time to decode the secrets/data.</li>
</ol>

<p>Again, once a hacker has access to the device, it’s game over. They can even mess with the OS internals to defeat device attestation, but at least you can make their lives harder.</p>

<p>A final point to mention is packages like <code>react-native-dotenv</code> and <code>react-native-config</code>. I don’t like them because they can be misleading (and have caused me trouble compiling them in the past). These “environment variables” packages still package your environment variables inside the app bundle and then read them at runtime. While they have not intentionally deceived people into thinking they are secure, the naming and the mixing of real environment variables with what they do have at least led unaware developers to think their secrets are secure (speaking from personal experience).</p>

<p>The reason why environment variables in things like Docker containers and server environments are secure is that they reside in memory, are not persisted, and are isolated by running on the server where (hopefully) the only point of entry is a secure HTTP API. This is not the case for mobile apps (regardless of the language/framework you are using).</p>

<h1 id="user-data">User Data</h1>

<p>Given this knowledge, why should we bother encrypting user data? Well, again, if we consider the worst-case scenario, the world is bleak. But if we assume we are running on an untampered device/OS, the fact that we protect data from other apps and script-kiddies is still worthwhile. Most packages have some way of encrypting your data via an encryption key.</p>

<p>Which algorithm they use and if they are actually securing the data is a per-package question. Many of them (at least in the React Native world) have hand-rolled their encryption, use dubious implementations, or are outdated. It’s too much to cover in this article, so I will just give you an ideal workflow that should be secure (barring implementation errors in the libraries themselves):</p>

<h2 id="generate-and-securely-store-your-encryption-key">Generate and Securely Store Your Encryption Key</h2>

<p>Most packages tell you to do this:</p>

<pre><code class="language-ts">const myKey = "password_is_password";

const storage = MyStateLibrary.create({
  encryptionKey: myKey,
});
</code></pre>

<p>The problem with this approach is that anyone can decompile your app and read the value of <code>myKey</code> (no matter how you obfuscate it). This is even worse in React Native, where you can just decompress an APK/IPA and take a look at the minified JS/TS code. I have mentioned in previous articles how looking into the JS bundle can leak valuable business logic and allow competitors to copy functionality.</p>

<p>Here is a better approach to generate and store your encryption key. I’ll use my package <code>op-s2</code> for this, but you can use <a href="https://docs.expo.dev/versions/latest/sdk/securestore/">Expo Secure Store</a> or <a href="https://github.com/oblador/react-native-keychain">react-native-keychain</a> they are all (more-or-less) equivalent but I tried to make op-s2 the simplest. Both work by storing data in the Keychain on iOS and by generating keys with the KeyStore API on Android, which are backed by hardware (when possible on Android) and are secure (as secure as it gets with untampered devices).</p>

<pre><code class="language-ts">import { set } from "@op-engineering/op-s2";
import { generateSecureRandom } from "react-native-securerandom";

async function generateKey() {
  // generate secure bytes using the t2 chip (SecRandomCopyBytes) and Secure Random on Android
  const secureBytes = await generateSecureRandom(42);

  // on the latest versions of RN btoa is part of hermes
  const key = btoa(String.fromCharCode.apply(null, secureBytes));

  const { error } = set({
    key: "myKey",
    value: key,
    withBiometrics: true, // This means a FaceID/biometrics prompt will appear every time. See the docs if you don't want to use this
  });
}
</code></pre>

<p><code>withBiometrics</code> is the safest but most cumbersome option, as it requires user authentication every time you want to read this key. You can leave it out, and it will still be secure. How are these packages secure? Because KeyStore/Keychain actually allow access on a per-app bundle basis (with signature verification, I believe). You only have access to the data you have created; you cannot read values from other apps/processes. So, at least we have per-app security.</p>

<p>Then, when you start your storage, you can pass this key:</p>

<pre><code class="language-ts">const myKey = get({ key: "myKey", withBiometrics: true });

const storage = MyStateLibrary.create({
  encryptionKey: myKey,
});

const myKey = null;
// You can even trigger garbage collection to make a timed attack even harder
</code></pre>

<p>Again, nothing is truly secure, but at least we have an extra layer of protection. Clearing the memory is also a best practice to prevent leaks. We then rely on the library to have correctly implemented an encryption algorithm.</p>

<blockquote>
  <p>As a funny side note:
Apple’s Keychain is just an API wrapper against a SQLite database that has some OS protections bolted in.
Keystore is just an API for retrieving/generating/saving secure crypto keys. The actual API that saves data is EncryptedSharedPreferences, which just saves files to disk with encryption bolted on.</p>

  <p>:)</p>
</blockquote>

<h2 id="use-secure-storage">Use Secure Storage</h2>

<p>Once you have your encryption keys securely stored, it’s time to move on to storing the data itself securely. Here, some libraries are already prepared for that. MMKV allows you to specify an encryption key:</p>

<pre><code class="language-ts">import { get } from "@op-engineering/op-s2";
import { MMKV, Mode } from "react-native-mmkv";

const myKey = get({ key: "myKey", withBiometrics: true });

export const storage = new MMKV({
  id: `user-${userId}-storage`,
  path: `${USER_DIRECTORY}/storage`,
  encryptionKey: myKey,
  mode: Mode.MULTI_PROCESS,
});
</code></pre>

<p>Another alternative is using an encrypted fork of SQLite called SQLCipher, which you can use via <a href="https://github.com/OP-Engineering/op-sqlite">op-sqlite</a>. You just need to enable SQLCipher support in the <code>package.json</code>:</p>

<pre><code class="language-json">"op-sqlite": {
  "sqlcipher": true
}
</code></pre>

<p>Then, when you open your database:</p>

<pre><code class="language-ts">const { open } from '@op-engineering/op-sqlite';

const myKey = get({ key: "myKey", withBiometrics: true });

const db = open({
  name: 'my_secure_db.sqlite',
  encryptionKey: myKey
});
</code></pre>

<p>This will fully encrypt the data stored on disk with a bit of overhead. As long as your encryption key is not compromised, it should be safe.</p>

<h1 id="hardware-keys">Hardware Keys</h1>

<p>I have to mention hardware keys, which circumvent the issue of the attacker having remote access to the device. Since they are separate from the OS, they cannot be easily compromised (apart from being physically stolen) and provide an extra layer of security.</p>

<p>If your app requires an even higher level of security, it might be worth looking into them. I have bridged the Yubico SDK for RN, but it’s not currently open source. <a href="https://developers.yubico.com/Developer_Program/Guides/User_Loaded_Data.html">Although you cannot save data to a YubiKey</a>, authentication would be enough to use secure bytes as an encryption key. As I’ve shown in this article, as long as the encryption key is safe, you can consider your data safe enough. If someone is willing to sponsor the work, I would be willing to create a Turbo module to make this functionality available to React Native apps.</p>

<h1 id="encryption-algorithms">Encryption algorithms</h1>

<p>If you are on the market for rolling your own encryption or need some crypto math, just use <a href="https://github.com/margelo/react-native-quick-crypto">react-native-quick-crypto</a>, it’s a (re)implementation of the <a href="https://nodejs.org/api/crypto.html">node’s crypto module</a>. There are many people who are not fans of the API, doesn’t matter. It’s proven and fast since it uses C++ bindings. It’s also somewhat incomplete but more APIs can be added if you are willing to sponsor the work.</p>

<h1 id="conclusion">Conclusion</h1>

<p>It’s still worth looking into the <a href="https://reactnative.dev/docs/security#storing-sensitive-info">official RN documentation</a>; however, I hope this guide is a bit more hands-on.</p>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[Like any other software development framework, security should be a top priority when developing React Native applications. However, there are a lot of misconceptions, fueled by the existence of packages and the lack of targeted information.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ospfranco.com/assets/oscar.jpg" /><media:content medium="image" url="https://ospfranco.com/assets/oscar.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Rust modules in React Native</title><link href="https://ospfranco.com/post/2024/05/08/react-native-rust-module-guide/" rel="alternate" type="text/html" title="Rust modules in React Native" /><published>2024-05-08T15:00:00+02:00</published><updated>2024-05-08T15:00:00+02:00</updated><id>https://ospfranco.com/post/2024/05/08/react%20native%20rust%20module%20guide</id><content type="html" xml:base="https://ospfranco.com/post/2024/05/08/react-native-rust-module-guide/"><![CDATA[<p>This is a tutorial on how I integrate Rust modules, but in the video form I go over the concepts that actually make this work, so you can adjust and understand the tooling behind and you can maintain your integration.</p>

<iframe class="w-full h-96" src="https://www.youtube.com/embed/PPU4Hrz4J_s" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>

<h1 id="basic-setup">Basic Setup</h1>

<ul>
  <li>Set up Rust compiler on your computer, just follow the instructions on the Rust website (using <code>rustup</code>).</li>
  <li>In order to compile the Android version you are going to use the <code>ndk</code> create which simplifies the command to compile the rust library for Android. Install it via <code>cargo install ndk</code></li>
  <li>
    <p>Create a crate where we will put all of our Rust lib code and infra scripts. In my case I will call it <code>my_sdk</code></p>

    <pre><code class="language-bash">cargo new my_sdk
</code></pre>
  </li>
  <li>
    <p>Create a <code>rust-toolchain.toml</code> in the project folder you just created. This will add all the necessary architectures to compile your project:</p>

    <pre><code class="language-toml">[toolchain]
channel = "stable"
targets = ["x86_64-apple-ios", "aarch64-apple-ios", "aarch64-apple-ios-sim", "aarch64-linux-android", "armv7-linux-androideabi", "x86_64-linux-android", "i686-linux-android"]
</code></pre>
  </li>
  <li>Change name of <code>main.rs</code> to <code>lib.rs</code></li>
  <li>
    <p>Add your API code on lib.rs</p>

    <pre><code class="language-rust">#[no_mangle]
extern "C" fn sum(a: i32, b: i32) {
  a + b
}
</code></pre>
  </li>
  <li>
    <p>We will use a crate called <code>cbindgen</code> that will help us generate a C header for our Rust functions. We will automate the header creation by creating a <code>build.rs</code> that runs everytime our project is compiled/checked. First we are going to add the dependency as a <code>[build-dependencies]</code>, the project <code>Cargo.toml</code>:</p>

    <pre><code class="language-toml">[build-dependencies]
cbindgen = "0.26.0"
</code></pre>
  </li>
  <li>
    <p>Then on the root of the project create a <code>build.rs</code> file:</p>

    <pre><code class="language-rust">extern crate cbindgen;

use std::env;

fn generate_c_headers() {
    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();

    cbindgen::Builder::new()
        .with_crate(crate_dir)
        .with_language(cbindgen::Language::C)
        .with_include_guard("my_sdk_h")
        .with_autogen_warning(
            "/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */",
        )
        .with_namespace("my_sdk")
        .with_cpp_compat(true)
        .generate()
        .expect("Unable to generate bindings")
        .write_to_file("generated/include/my_sdk.h");
}

fn main() {
    // Tell Cargo that if the given file changes, to rerun this build script.
    // println!("cargo:rerun-if-changed=src/lib.rs");
    generate_c_headers();
}
</code></pre>
  </li>
  <li>
    <p>Modify the <code>cargo.toml</code> to compile as static library. You can also create a dynamic library that can be loaded on runtime on Android, but both should work. The <code>jni</code> dependency is only necessary if you are planing to call your code from Java/Kotlin.</p>

    <pre><code class="language-toml">[package]
name = "SDK"
version = "0.1.0"
edition = "2021"

[lib]
name = "SDK"
crate-type = ["staticlib"]

[dependencies]
libc = "0.2.80" # Allows to use c types CString, c_char, etc.
jni = "0.17.0" # Allows to write JNI bindings directly from Rust

[build-dependencies]
cbindgen = "0.26.0"
</code></pre>
  </li>
</ul>

<h1 id="ios">iOS</h1>

<ul>
  <li>
    <p>We are going to use <code>Make</code> to compile and package the library. No specific reason for it you can create your script on JS too.</p>

    <pre><code class="language-make">ARCHS_IOS = x86_64-apple-ios aarch64-apple-ios aarch64-apple-ios-sim
ARCHS_ANDROID = aarch64-linux-android armv7-linux-androideabi x86_64-linux-android i686-linux-android
LIB = libmy_sdk.a
XCFRAMEWORK = my_sdk.xcframework

all: ios android

ios: $(XCFRAMEWORK)

android: $(ARCHS_ANDROID)
  ./copy-android.sh

.PHONY: $(ARCHS_IOS)
$(ARCHS_IOS): %:
  cargo build --target $@ --release

.PHONY: $(ARCHS_ANDROID)
$(ARCHS_ANDROID): %:
  cargo ndk --target $@ --platform 31 --release

$(XCFRAMEWORK): $(ARCHS_IOS)
  lipo -create $(wildcard ../../target/x86_64-apple-ios/release/$(LIB)) $(wildcard ../../target/aarch64-apple-ios-sim/release/$(LIB)) -output simulator_fat/libmy_sdk.a
  xcodebuild -create-xcframework -library $(wildcard ../../target/aarch64-apple-ios/release/$(LIB)) -headers include -library simulator_fat/libmy_sdk.a -headers include -output $@
  ./copy-ios.sh
</code></pre>

    <blockquote>
      <p>You see on iOS we are creating a xcframework, that is because the architectures conflict (iOS and iOS sim m1), so we use a xcframework to package it nicely for Xcode to build our app.</p>
    </blockquote>
  </li>
  <li>The <code>copy-ios.sh</code> is just a simple scripts that copies the generated xcframework to a more convenient location. You can leave it out if you modify the locations manually.</li>
  <li>Add generated <code>.xcframework</code> to Xcode
    <ul>
      <li>If you are doing this on a single project then dragging and dropping is the easiest, just make sure in the project properties mark the xcframework as embed and sign.</li>
      <li>If you are doing this on React Native, as part of a library, then you need to modify your podspec. Just drop the <code>xcframework</code> somewhere and then on your podspec add <code>s.vendored_frameworks = "my_sdk.xcframework"</code></li>
    </ul>
  </li>
  <li>You should now be able to simply import the header file (<code>#include "my_sdk.h"</code>) and call any Rust function from any Obj-C++ file</li>
</ul>

<h1 id="android">Android</h1>

<ul>
  <li>
    <p>The <code>ndk</code> crate simplifies the generation of Android Rust modules massively. You need to have the variables set up properly though. Make sure you have the Android NDK properly installed in your system. Then set the following environment variables in your system. Change the NDK version to whatever you have installed or you need:</p>

    <pre><code class="language-bash">export ANDROID_SDK_ROOT=$HOME/Library/Android/sdk
export ANDROID_HOME=$HOME/Library/Android/sdk
export ANDROID_NDK_HOME=$ANDROID_HOME/ndk/25.1.8937393
</code></pre>
  </li>
  <li>
    <p>After the compilation is done, we need to place the files in the correct place, the <code>copy-android.sh</code> takes care of that:</p>

    <pre><code class="language-bash">#!/bin/bash
mkdir -p ../android/app/src/main/jniLibs
mkdir -p ../android/app/src/main/jniLibs/x86
mkdir -p ../android/app/src/main/jniLibs/arm64-v8a
mkdir -p ../android/app/src/main/jniLibs/armeabi-v7a
mkdir -p ../android/app/src/main/jniLibs/x86_64


cp ./target/i686-linux-android/release/libmy_sdk.so ../android/app/src/main/jniLibs/x86/libmy_sdk.so
cp ./target/aarch64-linux-android/release/libmy_sdk.so ../android/app/src/main/jniLibs/arm64-v8a/libmy_sdk.so
cp ./target/arm-linux-androideabi/release/libmy_sdk.so ../android/app/src/main/jniLibs/armeabi-v7a/libmy_sdk.so
cp ./target/x86_64-linux-android/release/libmy_sdk.so ../android/app/src/main/jniLibs/x86_64/libmy_sdk.so
</code></pre>
  </li>
  <li>
    <p>We need to tell cmake to link the library when compiling our native module, on the <code>CMakeLists.txt</code> file add the following:</p>

    <pre><code class="language-cmake">make_path(SET MY_SDK_LIB ${CMAKE_CURRENT_SOURCE_DIR}/jniLibs/${ANDROID_ABI}/libmy_sdk.a NORMALIZE)
add_library(my_sdk STATIC IMPORTED)
set_target_properties(my_sdk PROPERTIES IMPORTED_LOCATION ${MY_SDK_LIB})

target_link_libraries(tm
        jsi
        my_sdk
        react_nativemodule_core
        react_codegen_AppSpecs
)
</code></pre>
  </li>
  <li>We will still not be able to call our Rust code from Java, because we need to go through the JNI and the JNI is very picky regarding names, we need to create specific binding for Android, on the <code>lib.rs</code> and the following block</li>
  <li>We can finally call <code>make android</code> and the library will be created for us</li>
  <li>
    <p><strong>Optional</strong> If you want to call the functions from Java/Kotlin (and not from C++) you need to create another binding using Android’s JNI:</p>

    <pre><code class="language-rust">// On Android function names need to follow the JNI convention
pub mod android {
  extern crate jni;

  use self::jni::JNIEnv;
  use self::jni::objects::JClass;
  use self::jni::sys::jstring;

  #[no_mangle]
  pub unsafe extern fn Java_com_samplesdk_BindingsModule_helloWorld(env: JNIEnv, _: JClass) -&gt; jstring {
    let output = env.new_string("Hello from Rust!").expect("Couldn't create java string!");
    output.into_inner()
  }
}
</code></pre>
  </li>
  <li>
    <p>We can now create a RN Module (or JSI module) and simply load the library and call it (via JNI of course)</p>

    <pre><code class="language-java">package com.samplesdk;

import com.facebook.react.bridge.NativeModule;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;
import com.facebook.react.util.RNLog;
import java.util.Map;
import java.util.HashMap;

public class BindingsModule extends ReactContextBaseJavaModule {


    BindingsModule(ReactApplicationContext context) {
        super(context);
    }

    @Override
    public String getName() {
        return "Bindings";
    }

    @ReactMethod
    public void init(String apiKey) {
        RNLog.w(this.getReactApplicationContext(), "BindingsModule.init() called with apiKey: " + apiKey + "calling rust");
        String result = helloWorld();
        RNLog.w(this.getReactApplicationContext(), "Rust says: " + result);
    }

    private static native String helloWorld();
}
</code></pre>
  </li>
</ul>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[This is a tutorial on how I integrate Rust modules, but in the video form I go over the concepts that actually make this work, so you can adjust and understand the tooling behind and you can maintain your integration.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ospfranco.com/assets/oscar.jpg" /><media:content medium="image" url="https://ospfranco.com/assets/oscar.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Why I believe Swift is better than Rust</title><link href="https://ospfranco.com/why-I-believe-swift-is-better-than-rust/" rel="alternate" type="text/html" title="Why I believe Swift is better than Rust" /><published>2024-04-29T00:00:00+02:00</published><updated>2024-04-29T00:00:00+02:00</updated><id>https://ospfranco.com/why%20I%20believe%20swift%20is%20better%20than%20rust</id><content type="html" xml:base="https://ospfranco.com/why-I-believe-swift-is-better-than-rust/"><![CDATA[<p>Over the last year, I have been building software in native languages. C++, Swift, Kotlin and most recently Rust. Rust has been particularly tricky to get right and has given me an uneasy feeling.</p>

<h1 id="solving-memory-management">Solving memory management</h1>

<p>The big promise of Rust is to prevent memory allocation problems. It does this via the Borrow Checker which forces you to avoid leaky patterns from the get-go. The problem is that the borrow checker forces you to write manually safe code ALL THE TIME. Some of my thoughts are expressed at length in this recent <a href="https://loglog.games/blog/leaving-rust-gamedev/#rust-being-great-at-big-refactorings-solves-a-largely-self-inflicted-issues-with-the-borrow-checker">Rust article</a> that is making the rounds on the internet:</p>

<blockquote>
  <p>The most fundamental issue is that the borrow checker forces a refactor at the most inconvenient times. Rust users consider this to be a positive, because it makes them “write good code”, but the more time I spend with the language the more I doubt how much of this is true. Good code is written by iterating on an idea and trying things out, and while the borrow checker can force more iterations, that does not mean that this is a desirable way to write code. I’ve often found that being unable to just move on for now and solve my problem and fix it later was what was truly hurting my ability to write good code.</p>
</blockquote>

<p>While the specific use-case of writing Rust games may not be ideal for such a strict system as the borrow-checker I have found the tyrannical nature of it more cumbersome than helpful. On my normal day-to-day, there are very few pieces of code where I want to write the memory-safe code myself. Opening a file, and passing a variable to multiple functions, everything becomes 20x cumbersome.</p>

<p>The borrow-checker on a high level, dumps the responsibility of writing safe code to YOU. It’s a very useful helper but it just points at the correct path and doesn’t solve the problem <strong>for you</strong>.</p>

<h1 id="swift-has-become-my-favorite-language">Swift has become my favorite language</h1>

<p>After the last few years, I can only praise Swift. It’s not perfect, but it feels like the culmination of the C-like family of languages. It does a lot of the nice things Rust does. Explicit control, and exhaustive checks for branching code, yet it has dynamic syntax. But it also does them with automatic memory management.</p>

<p>Swift has taken all the lessons of the last 20 years of software development and dumped them into a useful language.</p>

<h1 id="the-feeling">The feeling</h1>

<p>Whenever I open a Swift file I wrote myself I can immediately pick up where I left. Whereas with Rust every function is a mess of <code>unwrap</code>, <code>clone</code>, <code>arc</code>, <code>box</code>. Ultimately, Rust solved the memory management problem at the interface between your hands and the keyboard and that makes coding too hard.</p>

<p>I don’t think Swift is perfect but is a joy to work with.</p>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[Over the last year, I have been building software in native languages. C++, Swift, Kotlin and most recently Rust. Rust has been particularly tricky to get right and has given me an uneasy feeling.]]></summary></entry><entry><title type="html">How to resolve duplicated libraries on Android</title><link href="https://ospfranco.com/how-to-resolve-duplicated-libraries-on-android/" rel="alternate" type="text/html" title="How to resolve duplicated libraries on Android" /><published>2023-12-07T00:00:00+01:00</published><updated>2023-12-07T00:00:00+01:00</updated><id>https://ospfranco.com/how%20to%20resolve%20duplicated%20libraries%20on%20android</id><content type="html" xml:base="https://ospfranco.com/how-to-resolve-duplicated-libraries-on-android/"><![CDATA[<p>If you have developed on Android long enough, you might have found an error like this:</p>

<pre><code class="language-sh">A failure occurred while executing com.android.build.gradle.internal.tasks.MergeNativeLibsTask$MergeNativeLibsTaskWorkAction
2 files found with path 'lib/arm64-v8a/libcrypto.so'
</code></pre>

<p>This is caused by two libraries/dependencies generating the same artifact (in this case, depending on OpenSSL which generates <code>libcrypto.so</code>). If you haven’t declared your dependency on OpenSSL, then the problem is a transitive dependency (you require A and B, and both require C).</p>

<p>There are a number of workarounds, but they all have potential issues, so here are some short explanations.</p>

<h1 id="exclude">Exclude</h1>

<p>The first solution you might try is the <code>exclude</code> command of gradle. This will only work if you are modifying the sources of one of the conflicting libraries. This basically tells Gradle: whenever you are packaging this library, exclude this files from the final bundle merge.</p>

<pre><code class="language-groovy">packagingOptions {
      excludes = [
        // ... other excluded files
        "**/libcrypto.so"
      ]
}
</code></pre>

<p>This will basically force your final application to contain one <code>libcrypto.so</code> and avoid any potential conflicts. The problem is than, if you remove the other dependency and no one is left to generate the .so, then you are out of luck and you will get an error saying the file is missing.</p>

<h1 id="pick-first">Pick first</h1>

<p>Another possible strategy is using <code>pickFirst</code>, it basically tells Gradle: “whatever you find first, just link against that”. The problem with this however is that it cannot be included in the offending library <code>build.gradle</code> but must be specified in the application’s <code>build.gradle</code> (since that is the parent scope that faces the conflict when compiling the dependencies)</p>

<pre><code class="language-groovy">packagingOptions {
  pickFirst '**/libcrypto.so'
}
</code></pre>

<h1 id="other-strategies">Other strategies</h1>

<p>There are other strategies that work on pure gradle dependencies, which might or might not work on React Native but you can give them a try.</p>

<h2 id="excluding-group">Excluding group</h2>

<p>Change the declared dependency to exclude the internal dependency</p>

<pre><code class="language-groovy">implementation ('junit:junit:4.12'){
    exclude group: 'org.hamcrest', module:'hamcrest-core' // exclude the transtive dependency
}
</code></pre>

<h2 id="explicitely-requiring-the-dependency">Explicitely requiring the dependency</h2>

<pre><code class="language-groovy">implementation 'junit:junit:4.12'
implementation 'org.hamcrest:hamcrest-core:1.3' // force the shared dependency version
</code></pre>

<h2 id="force-resolution">Force resolution</h2>

<p>This might force an older version into the dependencies</p>

<pre><code class="language-groovy">android {
    configurations.all {
        resolutionStrategy.force 'org.hamcrest:hamcrest-core:1.1'
    }
}
</code></pre>

<h1 id="version-missmatch">Version missmatch</h1>

<p>The problem with this solutions is that you are forcing a single version upon your dependencies, which might break because they might rely on the API of a particular version. I don’t know how to include two versions of the same library unfortunately, so the actual solution is to make sure you are on the latest versions and they all depend on the same transitive dependency version.</p>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[If you have developed on Android long enough, you might have found an error like this:]]></summary></entry><entry><title type="html">Swift 5.9 Notes</title><link href="https://ospfranco.com/swift-5.9-notes/" rel="alternate" type="text/html" title="Swift 5.9 Notes" /><published>2023-11-24T00:00:00+01:00</published><updated>2023-11-24T00:00:00+01:00</updated><id>https://ospfranco.com/swift%205.9%20notes</id><content type="html" xml:base="https://ospfranco.com/swift-5.9-notes/"><![CDATA[<p>Swift 5.9 has enabled direct interop with C++. This means you can directly call and interact with C++, as well as introduced a series of objects that allow to interact with integral and C++ class values directly (e.g. <code>std::string</code>).</p>

<p>In order to enable the C++ interop, you need to be on XCode 15 (I think), and your projects needs to be Swift enabled. If you are not sure, you only need to add a Swift file and the bridging header will be created for you and all the Swift build settings will be enabled on XCode.</p>

<p>Afterwards you need to go into the <code>Build Settings</code> → <code>Swift Compiler - Language</code> → <code>C++ and Obj-C++ Interoperability</code> and change the value from C to C++</p>

<p>If you want to do the same in a CocoaPods project you need to modify the pod config like this:</p>

<pre><code class="language-ruby">s.pod_target_xcconfig = {
  'SWIFT_OBJC_INTEROP_MODE' = 'objcxx'
}
</code></pre>

<p>Clang has issues with headers (it generates a module map, topic for another day). Instead of importing headers directly from your dependency, you should import the umbrella header.</p>

<pre><code class="language-C++">#import &lt;jsi/jsi.h&gt;
</code></pre>

<p>You should import everything with</p>

<pre><code class="language-C++">#import &lt;mypod-umbrella.h&gt;
</code></pre>

<p>Afterwards you are in the clear, you should be able to call any C++ function/class from your Swift code and viceversa.</p>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[Swift 5.9 has enabled direct interop with C++. This means you can directly call and interact with C++, as well as introduced a series of objects that allow to interact with integral and C++ class values directly (e.g. std::string).]]></summary></entry><entry><title type="html">Mix C++, Obj-C and Swift files in a single XCode target</title><link href="https://ospfranco.com/post/2023/11/24/mix-c++,-obj-c-and-swift-files-in-a-single-xcode-target/" rel="alternate" type="text/html" title="Mix C++, Obj-C and Swift files in a single XCode target" /><published>2023-11-24T00:00:00+01:00</published><updated>2023-11-24T00:00:00+01:00</updated><id>https://ospfranco.com/post/2023/11/24/mix%20c++,%20obj-c%20and%20swift%20files%20in%20a%20single%20xcode%20target</id><content type="html" xml:base="https://ospfranco.com/post/2023/11/24/mix-c++,-obj-c-and-swift-files-in-a-single-xcode-target/"><![CDATA[<p>If you have an XCode project where you are trying to mix C++, Obj-C and Swift, things will not work. If you only deal with Obj-C++ everything compiles fine, but the moment you add Swift into the mix you might start getting a slew of errors on your header files.</p>

<p>The root issue is the <a href="https://stackoverflow.com/questions/47788422/cannot-use-namespace-and-cannot-include-standard-c-library-in-my-h-files">Swift compiler</a>, it doesn’t support C++, yet it still tries to compile C headers on its own. Whenever you have Swift files together with C++ files, it’s the Swift compiler that will kick-in in a first pass (followed by CLang? maybe before? doesn’t matter) and will try to compile the headers as C headers independently of what you tell it, file extensions, etc.</p>

<p>You will then start getting errors based on the C++ syntax (if you used any). For example if you are using namespaces (which don’t exist on C), you will get <a href="https://github.com/CocoaPods/CocoaPods/issues/12105#issuecomment-1824455557">invalid syntax errors</a>.</p>

<p>There are a couple workarounds. First you can wrap every single bit of C++ syntax in your headers around a macro that checks if the compiler supports C++:</p>

<pre><code class="language-C++">#if defined __cplusplus
extern "C" {
#endif

#if defiend __cplusplus

class Foo
{
    void bar(int c);
}
#endif
struct FooHandle;

void Foo_bar(struct FooHandle* foo, int c);

#if defined __cplusplus
}
#endif
</code></pre>

<p>Every header you create you will have to manually modify to check for syntax errors.</p>

<h1 id="cocoapods">Cocoapods</h1>

<p>Cocoapods has a special problem with this, since it generates an umbrella header that will also get compiled by the Swift compiler and it will fail. Either of the methods described above will workaround the issue for now.</p>

<p>Another alternative is to hide the header files from the XCode file system, yet still provide them via flags that will get passed to the compilers:</p>

<pre><code class="language-ruby">require "json"

package = JSON.parse(File.read(File.join(__dir__, "package.json")))

Pod::Spec.new do |s|
  s.name           = "matrix"
  s.version        = package["version"]
  s.summary        = package["description"]
  s.homepage       = package["homepage"]
  s.license        = package["license"]
  s.authors        = package["author"]
  s.platforms      = { :ios =&gt; "13.0" }

  s.pod_target_xcconfig = {
    "DEFINES_MODULE" =&gt; "YES",
    "SWIFT_COMPILATION_MODE" =&gt; "wholemodule",
    "CLANG_CXX_LANGUAGE_STANDARD" =&gt; "c++17",
    # ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
    "HEADER_SEARCH_PATHS" =&gt; "\"$(PODS_TARGET_SRCROOT)/cpp/\"/** " # This will link the headers at compile time, flag passed directly to the compiler
  }

  # ↓↓↓↓↓↓↓↓↓↓↓↓
  s.source_files = "ios/**/*.{mm,swift}", "cpp/**/*.{cpp,c}" # Do not include the headers in the sources, then XCode won't try to compile them

  # ↓↓↓↓↓↓↓↓↓↓↓↓↓↓
  s.preserve_paths = [
    "cpp/**/*.h",
    "ios/**/*.h"
  ]

  s.dependency "React"
  s.dependency "React-Core"
  s.dependency "React-callinvoker"
end
</code></pre>

<p>One side effect is that the headers will not appear on the project explorer view on XCode, which is annoying if you are developing something from scratch, you can still ⌘ + click to open it, but it won’t show navigation side bar.</p>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[If you have an XCode project where you are trying to mix C++, Obj-C and Swift, things will not work. If you only deal with Obj-C++ everything compiles fine, but the moment you add Swift into the mix you might start getting a slew of errors on your header files.]]></summary></entry><entry><title type="html">Get iOS simulator local home folder on macOS</title><link href="https://ospfranco.com/post/2023/11/13/get-ios-simulator-local-home-folder-on-macos/" rel="alternate" type="text/html" title="Get iOS simulator local home folder on macOS" /><published>2023-11-13T00:00:00+01:00</published><updated>2023-11-13T00:00:00+01:00</updated><id>https://ospfranco.com/post/2023/11/13/get%20ios%20simulator%20local%20home%20folder%20on%20macos</id><content type="html" xml:base="https://ospfranco.com/post/2023/11/13/get-ios-simulator-local-home-folder-on-macos/"><![CDATA[<p>Sometimes you want to really see what is on the file system of iOS. Even the simulator file system is useful to check if files are correctly downloaded or sometimes you might want to check a database file manually.</p>

<p>You can easily get the directory printed out from the XCode console. When you application is paused or a debugger breakpoint is hit, you can type <code>po NSHomeDirectory()</code> and it will print out the local directory.</p>

<p><img src="https://ospfranco.com/assets/pohomedirectory.png" alt="home directory print out" title="PO NSHomeDirectory" /></p>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[Sometimes you want to really see what is on the file system of iOS. Even the simulator file system is useful to check if files are correctly downloaded or sometimes you might want to check a database file manually.]]></summary></entry><entry><title type="html">SQLite for React Native, but 5x faster and 5x less memory</title><link href="https://ospfranco.com/post/2023/11/09/sqlite-for-react-native,-but-5x-faster-and-5x-less-memory/" rel="alternate" type="text/html" title="SQLite for React Native, but 5x faster and 5x less memory" /><published>2023-11-09T00:00:00+01:00</published><updated>2023-11-09T00:00:00+01:00</updated><id>https://ospfranco.com/post/2023/11/09/sqlite%20for%20react%20native,%20but%205x%20faster%20and%205x%20less%20memory</id><content type="html" xml:base="https://ospfranco.com/post/2023/11/09/sqlite-for-react-native,-but-5x-faster-and-5x-less-memory/"><![CDATA[<p>I created a new sqlite module for react-native: <a href="https://github.com/OP-Engineering/op-sqlite">op-sqlite</a>. Although it started as some exploration of possibilities, the performance gains where so large that it turned out to be a entire re-write of the module.</p>

<h1 id="quick-sqlite">quick-sqlite</h1>

<p>I wrote <a href="https://github.com/ospfranco/react-native-quick-sqlite">quick-sqlite</a> last year after I learned about React Native JSI, a way to bridge C++ code to JavaScript. The idea was simple and I took a peek at existing libraries. One basically takes the arguments passed from JavaScript, and then just call the SQLite APIs, then collect the results of the queries and pass them back to JavaScript.</p>

<p>quick-sqlite already produced a major improvement in performance over the old bridge modules, where data had to be serialized to JSON and then passed between native and JavaScript. The flow was pretty simple:</p>

<p><img src="https://ospfranco.com/assets/quick-sqlite-flow.png" alt="quick-sqlite-flow" title="Quick SQLite flow" /></p>

<h1 id="where-quick-sqlite-fell-short">Where quick-sqlite fell short</h1>

<p>There were, however, some issues with quick-sqlite. People complained although it was fast, queries would run out of memory or it would not be fast enough. Given that this was open source work and I already gotten what I wanted I did not pursue further optimizations further. At some point it was not fun and I handed over quick-sqlite to Margelo and went for a long vacation.</p>

<p>I’ve been back at work for a few months and I have seen the value quick-sqlite provides to companies large and small. But people <a href="https://github.com/margelo/react-native-quick-sqlite/pull/30#issuecomment-1801378465">kept asking if it could be made faster</a>. They already had some good ideas: try to reduce the amount of created strings, use HostObjects to reduce memory foot-print, and so on. Just out of curiosity I decided to try a few things.</p>

<p>In order to really see differences, I set up a test of a database of 300k records, mix of strings, ints and doubles. At lower scales the differences might be so tiny that they don’t really matter.</p>

<h1 id="migrate-to-hostobjects">Migrate to HostObjects</h1>

<p>The first obvious idea was migrating to HostObjects (if you don’t know what they are, <a href="https://www.youtube.com/watch?v=_BNinSbzZTE">I made a video about them</a>, but think C++ classes bridged to JS). HostObjects are not a cure to all, but they would immediately provide a big benefit: memory consumption would be reduced. On the old flow, I would get the results from SQLite, store them in a vector, and then when I got access to the JS context again, iterate and recreate all the data again in JSI (read: plain JS) objects. This meant that all the price of converting/transfering data from native to JS, was paid upfront. By using HostObjects one can avoid paying this price of copying strings and other values. They would be created once and then stored in memory, when the JS side reaches inside them then they do the conversion of data at that point in time.</p>

<p>It is not perfect, since I’m shifting the price paid before upfront into some cost when accessing the data. But testing showed that access was just the same, and memory consumption was halved! This meant queries that would OOM before now could be run without problem.</p>

<h1 id="get-rid-of-holding-struct">Get rid of holding struct</h1>

<p>Another issue was I created a Struct to hold different type of data, due to the nature of JS any value you receive can be of these types:</p>

<pre><code class="language-c++">struct QuickValue {
  int intVal;
  double doubleVal;
  std::string strVal;
  bool boolVal;
  std::string type; // used to store which type of data this was holding
}
</code></pre>

<p>There is no justification for this structure other than: I didn’t knew any better, my c++-fu was weak. I knew that using this struct would allocate too much extra memory and was wasteful, I just didn’t imagine how much. Allocating memory and moving objects around in the heap has a big cost, not only in memory but sometimes in performance!</p>

<p>When browsing the web and other peoples code, I came to learn about <a href="https://en.cppreference.com/w/cpp/utility/any">std::any</a>, which was introduced in C++ 17. It basically functions the same as my struct to hold data (internally it just stores a pointer <code>void *</code>). I got rid of the struct and swapped all references for <code>std::any</code> and the performance gains were amazing, all of the sudden the performance of the module was 3x as fast. It came with a cost however. <code>std::any</code> is awkward to use, it doesn’t really store any type information, and at best you can only run code when you know the type of the thing you put in there.</p>

<p>When reading on how to do certain operations, a lot of answers pointed towards <a href="https://en.cppreference.com/w/cpp/utility/variant">std::variant</a>. After getting the code to compile with <code>std::any</code> I decided to give <code>std::variant</code> a try. Although on the surface it looked the same, it is bounded to types one declared, because it cannot hold any type of data, the compiler can get a little smarter about it. The performance gain was also staggering here, all of the sudden I was almost reaching 6x times the performance.</p>

<pre><code class="language-c++">#include &lt;variant&gt;

struct ArrayBuffer {
    std::shared_ptr&lt;uint8_t&gt; data;
    size_t size;
};


using JSVariant = std::variant&lt;nullptr_t, bool, int, double, long, long long, std::string, ArrayBuffer&gt;;
</code></pre>

<h1 id="turning-the-problem-around">Turning the problem around</h1>

<p>I had a nagging feeling that somehow I was just wasting so much memory by creating HostObjects that are basically maps, therefore store the same keys over and over again (remember, I switched from creating JS objects to keeping them in HostObjects, but each HostObject contained the same keys). Then I realized I could turn the entire thing around. Instead of thinking of each HostObject as a completely stand alone entity, they could all share the same key set, and only store the actual values!</p>

<p>It took a little while for me to wrap my head around shared pointers. How to store the key set in a vector, that by using a shared_pointer in the HostObjects instances would not get de-allocated. The final result is a combination of what I call a <a href="https://github.com/OP-Engineering/op-sqlite/blob/main/cpp/DumbHostObject.h">DumbHostObject</a> and <a href="https://github.com/OP-Engineering/op-sqlite/blob/main/cpp/DynamicHostObject.cpp">DynamicHostObject</a>, the dumb objects only hold data, and the dynamic objects can hold anything (that can also be accessed from the JS side), but by combining the two, one can save memory by sharing the key set (in a DynamicHostObject) among many results (DumbHostObjects).</p>

<p>As it turns out, this slightly decreased performance (completely unexpected, who would have thought passing shared pointers around was so expensive), but memory allocation was halved again! That in my opinion is a worthy trade. The original query in quick-sqlite took over two seconds and required 1.2 gbs in memory on iOS. This now runs in ~500ms and requires only 250mbs of memory. The Android performance gains are masive as well, reaching almost 8x the speed.</p>

<table>
  <thead>
    <tr>
      <th>Library</th>
      <th>iPhone 15 Pro</th>
      <th>Galaxy S22</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>quick-sqlite</td>
      <td>2719ms</td>
      <td>8851ms</td>
    </tr>
    <tr>
      <td>expo-sqlite</td>
      <td>2293ms</td>
      <td>10626ms</td>
    </tr>
    <tr>
      <td>op-sqlite</td>
      <td>507ms</td>
      <td>1125ms</td>
    </tr>
  </tbody>
</table>

<h1 id="troubles-in-paradise">Troubles in paradise</h1>

<p>Remember what I said that HostObjects are not perfect? Turns out property access is quite slow, not only because the objects store the keys in a Vector (I tried an <code>std::unordered_map</code>, it’s even slower, hashing functions and memory layout uh?). So in a way I’m bullshitting you a bit. When running a 300k query, this numbers are fantastic, but if you are running something that returns a couple of hundred of results, you might see no difference at all.</p>

<p>As it turns out, this slow access, might not be even related to the HostObject itself, but any object that is created with the <code>jsi::Object()</code> API, when I tested <code>quick-sqlite</code> the numbers accessing data are quite similar. <code>expo-sqlite</code> was super fast on accessing data, but it zips the data on the JS side, so it seems that is the only way to create fast access objects. This means however you will always pay the price upfront for such large queries.</p>

<p>There are a few final optimizations that can be done, such as inserting keys in the shared vector with some sorting, so then accessing can be done via binary search, but I will leave it for later. Other optimizations include trying to inline more functions, but I think I have reached the end of what is possible with the JSI.</p>

<p>The next big step in performance will come from Static Hermes, where we can finally call SQLite code directly from JS without the need of HostObjects, shared pointers and so on. There will be one major difficulty though, static hermes is still single threaded, so getting React Native to call large queries without hanging will require creating a multi-threaded messaging system, AKA web-workers. I would definetely would like to tackle this problem and then create a new version of op-sqlite with that!</p>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[I created a new sqlite module for react-native: op-sqlite. Although it started as some exploration of possibilities, the performance gains where so large that it turned out to be a entire re-write of the module.]]></summary></entry></feed>