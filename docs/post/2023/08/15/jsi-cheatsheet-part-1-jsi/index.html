<head>
  <link rel="preconnect" href="https://rsms.me/" />
  <link rel="stylesheet" href="https://rsms.me/inter/inter.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta charset="utf-8" />
  <link
    rel="shortcut icon"
    type="image/x-icon"
    href="/assets/favicon.ico"
  />
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>JSI Cheatsheet: Part 1 - C++ | Oscar Franco</title>
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="JSI Cheatsheet: Part 1 - C++" />
<meta name="author" content="Oscar Franco" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="With JSI bindings RN devs will have to deal with the delicacies of memory management, more specific types and so on. Having written my own JSI library had to learn as I ran, painful process, so here are all the parts where I cut myself." />
<meta property="og:description" content="With JSI bindings RN devs will have to deal with the delicacies of memory management, more specific types and so on. Having written my own JSI library had to learn as I ran, painful process, so here are all the parts where I cut myself." />
<link rel="canonical" href="https://ospfranco.com/post/2023/08/15/jsi-cheatsheet-part-1-jsi/" />
<meta property="og:url" content="https://ospfranco.com/post/2023/08/15/jsi-cheatsheet-part-1-jsi/" />
<meta property="og:site_name" content="Oscar Franco" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-08-15T15:00:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="JSI Cheatsheet: Part 1 - C++" />
<meta name="twitter:site" content="@ospfranco" />
<meta name="twitter:creator" content="@Oscar Franco" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Oscar Franco"},"dateModified":"2023-08-15T15:00:00+02:00","datePublished":"2023-08-15T15:00:00+02:00","description":"With JSI bindings RN devs will have to deal with the delicacies of memory management, more specific types and so on. Having written my own JSI library had to learn as I ran, painful process, so here are all the parts where I cut myself.","headline":"JSI Cheatsheet: Part 1 - C++","mainEntityOfPage":{"@type":"WebPage","@id":"https://ospfranco.com/post/2023/08/15/jsi-cheatsheet-part-1-jsi/"},"url":"https://ospfranco.com/post/2023/08/15/jsi-cheatsheet-part-1-jsi/"}</script>
<!-- End Jekyll SEO tag -->

  <link rel="stylesheet" href="/css/site.css" />
</head>

<html>
  <header class="w-full flex flex-col items-center justify-center pt-12 pb-4">
  <!-- <img src="/assets/bg.png" class="" /> -->
  <div class="w-full max-w-4xl flex items-center gap-2 px-4">
    <a href="/" class="flex-1 flex items-center text-black dark:text-white"
      >
      <img src="/assets/oscar.jpg" class="w-8 h-8 rounded-xl mr-2 object-cover" />
      Oscar Franco</a
    >

    <!-- <div class="h-2 w-2 rounded-full bg-green-400 animate-pulse"></div>
    <a href="mailto:ospfranco@gmail.com"
    target="_blank" class="text-sm">
      Available for freelance work
    </a> -->
  </div>
</header>


<body class="flex flex-col items-center">
  <div class="px-4 pt-8 min-h-screen xl:max-w-4xl w-full">
    <div class="xl:mx-auto flex flex-col">
      <h1 class="text-black dark:text-white text-lg font-semibold sm:text-4xl">
        JSI Cheatsheet&#58; Part 1 - C++
      </h1>

      <p class="mt-2 text-neutral-500 text-sm">
        August 2023
      </p>

      <div class="pt-4 pb-20 markdown"><p>With JSI bindings RN devs will have to deal with the delicacies of memory management, more specific types and so on. Having written my own JSI library had to learn as I ran, painful process, so here are all the parts where I cut myself.</p>

<p>I‚Äôm going to try to use small code snippets to show you, because written explanations get convoluted fast.</p>

<h2 id="contents">Contents</h2>

<h2 id="the-basics">The basics</h2>

<p>Not gonna go over the basics, how to declare an int, double, functions, etc. I‚Äôm trying to teach you how to run, not how to walk, go to youtube look at any of the basic tutorials, a couple of hours is more than enough</p>

<p>This is what I watched for like 20 mins:</p>

<p>https://www.youtube.com/watch?v=vLnPwxZdW4Y&amp;t=11682s</p>

<p>I can write a lot but at the end of the day you will need to write the code, you can set up the toolchain in your machine or you can just go to <a href="https://replit.com/languages/cpp">replit with c++</a>, you won‚Äôt be able to test JSI code, but you can play around with the basics.</p>

<p>Before we start I need to teach your JavaScript brain some of the not so basic yet not so advanced stuff.</p>

<h1 id="not-basic-yet-not-advanced-stuff">Not basic yet not advanced stuff</h1>

<h2 id="namespaces">Namespaces</h2>

<p>TypeScript also has a concept of namespaces, but they are not widely used (unless you wrote them for your library). Therefore it is somewhat confusing seeing them all over the place on C++.</p>

<p>Example without namespace:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">=</span> <span class="s">"my string!"</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>üö® The <code class="language-plaintext highlighter-rouge">::</code> operator is similar to a <code class="language-plaintext highlighter-rouge">.</code> but is meant to be used with namespaces only</p>
</blockquote>

<p>You can use a namespace module wide and life becomes prettier:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">string</span> <span class="o">=</span> <span class="s">"my string!"</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>You can use more than one namespace in each file. This (of course) breaks down if you have two namespaces that use the same names.</p>

<h2 id="macros">Macros</h2>

<p>Unlike on JavaScript which is the WYSIWYG equivalent of programming languages, on C++ you can dynamically modify your code before it gets compiled, you do this via macros.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Portable wrapper for mkdir. Internally used by mkdir()
 * @param[in] path the full path of the directory to create.
 * @return zero on success, otherwise -1.
 */</span>
<span class="kt">int</span> <span class="nf">_mkdir</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if _POSIX_C_SOURCE
</span>  <span class="k">return</span> <span class="n">mkdir</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
<span class="cp">#else
</span>  <span class="k">return</span> <span class="n">mkdir</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="mo">0755</span><span class="p">);</span>
<span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div>

<p>Ignore everything except the stuff with <code class="language-plaintext highlighter-rouge">#</code>, here the macro is checking for the <code class="language-plaintext highlighter-rouge">_POSIX_C_SOURCE</code> environment variable, if the flag is present when you compile the code, then the code inside the true branch will be inserted and compiled, if not the false branch will be compiled.</p>

<h2 id="auto-type">Auto type</h2>

<p>C++ actually has dynamic allocation type‚Ä¶ but be careful! Useful if you are a C++ noob with types or you are quickly testing, but I just try to stay away from it when possible</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">19</span><span class="p">;</span> <span class="c1">// auto here will take the int type</span>
</code></pre></div></div>

<h2 id="constant-variables">Constant variables</h2>

<p>You can declare a constant variable by using the <code class="language-plaintext highlighter-rouge">const</code> type, when you are declaring your functions this will be important to make sure you don‚Äôt overwrite the variable (on the direct memory address) for the rest of your code</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// dangerous</span>
<span class="kt">void</span> <span class="nf">doSomethingFunny_wrong</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">foo</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">foo</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> <span class="c1">// ‚ö†Ô∏è modifies the direct memory address, will mess up your program</span>
<span class="p">}</span>

<span class="c1">// safer(ish)</span>
<span class="kt">void</span> <span class="nf">doSomethingFunny</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">foo</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">foo</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> <span class="c1">// doesn't compile, cannot modify const</span>
<span class="p">}</span>

<span class="c1">// to declare a variable as constant</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">foo</span> <span class="o">=</span> <span class="mi">19</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="vectors-variable-size-arrays">Vectors (variable size arrays)</h2>

<p>JavaScript makes you think that your arrays are infinitely growable, when in reality the one that needs to grow is you (üëä), so now you will have to deal with arrays like a real man (or real woman), arrays are fixed the moment you create them, you cannot just append stuff to them‚Ä¶ that is if you are using pure C, C++ gives us the <code class="language-plaintext highlighter-rouge">vector</code> class:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
	<span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">);</span>
	<span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">"I miss"</span><span class="p">);</span>
	<span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">"Javascript"</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Just be careful, the vector will hold a chunk of memory for you to insert stuff, once you go over the reserved space, it will have to reserve a bigger chunk and copy all the data to it</p>

<h2 id="maps">Maps</h2>

<p>Needless to say there is also maps for those among you who cannot even without JavaScript</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
</span>
<span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">myMap</span> <span class="o">=</span> <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span><span class="p">();</span>

<span class="n">myMap</span><span class="p">[</span><span class="s">"I miss"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Javascript"</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="structs">Structs</h2>

<p>The time might come where you need to bundle more data in a more complex structure than maps or vectors, there you need to create a struct. Be orderly and create it in it‚Äôs own header file.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// myStruct.h</span>
<span class="k">struct</span> <span class="nc">MyLittleStruct</span>
<span class="p">{</span>
	<span class="n">string</span> <span class="n">message</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>You can later use it in your other files</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">MyLittleStruct</span> <span class="nf">createALittleStruct</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">MyLittleStruct</span><span class="p">{</span>
		<span class="s">"I'm ready to cry"</span><span class="p">,</span>
		<span class="mi">12</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>‚ö†Ô∏è JavaScript will not understand any of this vector/map/struct mumbo jumbo, you will need to convert it at a later point to the appropriate JSI objects.</p>
</blockquote>

<h1 id="the-advanced-stuff">The advanced stuff</h1>

<h2 id="a-pointer-is-a-memory-address">A <strong>pointer is a memory address</strong></h2>

<p>Once you go beyond simple functions becomes super important, but only Einstein levels of intellect have the brain power and time to really understand the topic, you and me as mere mortals need to know only this:</p>

<blockquote>
  <p>üö® <strong>A pointer is a memory address</strong></p>
</blockquote>

<p>Get a tattoo of it if you can, whenever you use pointers it will also subtly change the semantics of your functions, but let‚Äôs just start with the basics:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// A regular integer variable</span>
<span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">19</span><span class="p">;</span> <span class="c1">// 19</span>

<span class="c1">// The "&amp;" operator returns the pointer (memory address) of a variable</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">age</span><span class="p">;</span> <span class="c1">// "0x6ef07b"</span>

<span class="c1">// A pointer variable (that points to an integer)</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">pAge</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">age</span><span class="p">;</span> <span class="c1">// 0x6ef07b</span>

<span class="c1">// Why does the pointer also have an int?</span>
<span class="c1">// because just a memory address is not useful</span>
<span class="c1">// You need to be able to cast it back into the original data</span>
<span class="c1">// The "*" operator "dereferences" the pointer = reads memory and casts it back to the original data</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">pAge</span><span class="p">;</span> <span class="c1">// "19"</span>
</code></pre></div></div>

<h2 id="pass-by-value-and-by-reference">Pass by value and by reference</h2>

<p>While Javascript also has pass by value and by reference, there you cannot modify the semantics, but on C++ you can:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="c1">// The "&amp;" operator here does not mean to get the pointer</span>
<span class="c1">// but that the argument passed should not copied but rather "referenced"</span>
<span class="kt">int</span> <span class="nf">sumByReference</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">result</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">+</span> <span class="mi">9</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// A normal function</span>
<span class="kt">int</span> <span class="nf">sumByValue</span><span class="p">(</span><span class="kt">int</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">result</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">+</span> <span class="mi">9</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"result variable: "</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> 	<span class="c1">// result variable: 0</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Sum by value: "</span> <span class="o">&lt;&lt;</span> <span class="n">sumByValue</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> 	<span class="c1">// Sum by value: 19</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"result variable: "</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> 	<span class="c1">// result variable: 0</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Sum by reference: "</span> <span class="o">&lt;&lt;</span> <span class="n">sumByReference</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Sum by reference: 19</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"result variable: "</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> 	<span class="c1">// result variable: 19</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="strings">Strings</h2>

<p>On C there is no string class, it‚Äôs all done with raw bytes and pointers, C++ has <code class="language-plaintext highlighter-rouge">std::string</code> which makes it easier, but a lot of APIs still deal with C-like strings, so it‚Äôs important to understand them</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// in C++</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">hello</span> <span class="o">=</span> <span class="s">"I'm a Javascript princess"</span><span class="p">;</span>

<span class="c1">// Create a C-Like string</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">myString</span> <span class="o">=</span> <span class="n">hello</span><span class="p">.</span><span class="n">c_str</span><span class="p">();</span>
</code></pre></div></div>

<p>This means the <code class="language-plaintext highlighter-rouge">*mystring</code> pointer ‚Üí points to the first byte (ASCII ‚Üí 1byte = 1char, also UTF-8 but other encodings need more bytes) of the string, you can ‚Äúreconstruct‚Äù your string by walking byte by byte</p>

<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c787b649-7083-43da-929e-5f23165a4127/Frame_1.png" alt="Frame 1.png" /></p>

<p>But how do you know when the string ends? by convention you mark the end of a string by using a null pointer (<code class="language-plaintext highlighter-rouge">\0</code>)</p>

<p>So then when you need to pass c_like strings in functions, you pass only the pointer</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="nf">takesAString</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">myCString</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">myCString</span><span class="p">);</span> <span class="c1">// convert to a c++ std::string</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>‚ö†Ô∏è This is not only used for strings, but whenever to pass arrays of stuff in without C++ fancy classes (no vectors, maps, etc). E.g: <code class="language-plaintext highlighter-rouge">jsi::Value *args</code> = array of <code class="language-plaintext highlighter-rouge">jsi::Values</code>, but unlike strings for other types of arrays you will have to pass/receive the length of the array as an integer (sometimes with a special <code class="language-plaintext highlighter-rouge">size_t</code> type).</p>
</blockquote>

<h2 id="scopecontext-lifecycles--memory-de-allocations-Ô∏è">Scope/context Lifecycles / Memory de-allocations ‚ö†Ô∏è</h2>

<p>This is one <strong>WILL BITE YOU IN THE ASS.</strong> Important topic because unlike JS where you can just pass stuff around and it will (mostly) be fine, on C++ your variables will be de-allocated and you will end up with trash.</p>

<p>But it‚Äôs important to note, C++ does not have a garbage collector, it just re-uses memory as the stack/heap get re-used.</p>

<p>It is specially important for JSI since current API operates with lambdas and the context (calling function) were they are created is garbage collected and they need capture semantics.</p>

<p>Let‚Äôs say you have an initialization function, that function has some variables declared inside:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">initMyModule</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// using a char* just to illustrate my point and keep the direct memory reference</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">docPath</span> <span class="o">=</span> <span class="s">"/usr/osp/Documents/"</span><span class="p">;</span>

	<span class="n">initDatabaseModule</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">docPath</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In order to initialize your module you call another module where you pass such variables, BUT inside that module you have functions that will outlive the original scope of the calling module:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ATTENTION: Pseudo-code</span>

<span class="c1">// my database module</span>

<span class="c1">// remember the pass by reference (&amp;) part?</span>
<span class="c1">// This function takes a pointer via the "*" operator</span>
<span class="kt">void</span> <span class="nf">initDatabaseModule</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">docPath</span><span class="p">)</span> <span class="p">{</span>

	<span class="c1">// this is a function with a lambda inside</span>
	<span class="n">std</span><span class="o">::</span><span class="n">function</span> <span class="n">openDatabase</span><span class="p">(</span><span class="n">string</span> <span class="n">dbName</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// some code to initialize a database</span>
		<span class="k">return</span> <span class="n">createDbFile</span><span class="p">(</span><span class="n">dbName</span><span class="p">,</span> <span class="n">docPath</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">// Then let's say you make this function globally available to the JS context</span>
	<span class="c1">// (Foreshadowing to JSI üòâ)</span>
	<span class="n">exposeToJS</span><span class="p">(</span><span class="n">openDatabase</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Well‚Ä¶ this will compile just fine, but when you try to call <code class="language-plaintext highlighter-rouge">openDatabase</code> from JavaScript, the <code class="language-plaintext highlighter-rouge">docPath</code> variable (pointer) will no longer contain a string, it will contain random bytes, that is because the context of the <code class="language-plaintext highlighter-rouge">initMyModule</code> function has been freed up, and some other piece of code has (could have) re-written that space.</p>

<blockquote>
  <p>‚ö†Ô∏è <strong>Unlike JS, you need to be really careful on the references you are passing, because they can be moved/garbage collected.</strong></p>
</blockquote>

<p>This brings us to capture semantics and how to work around this issues, for this type of module level variables one workaround is to declare a module variable:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ATTENTION: Pseudo-code</span>

<span class="c1">// my database module</span>

<span class="c1">// non-deallocatable reference</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">myDocPath</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">initDatabaseModule</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">docPath</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// We create a copy</span>
	<span class="n">myDocPath</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">docPath</span><span class="p">);</span>

	<span class="n">std</span><span class="o">::</span><span class="n">function</span> <span class="n">openDatabase</span><span class="p">(</span><span class="n">string</span> <span class="n">dbName</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// some code to initialize a database</span>
		<span class="k">return</span> <span class="n">createDbFile</span><span class="p">(</span><span class="n">dbName</span><span class="p">,</span> <span class="n">myDocPath</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
	<span class="p">}</span>

	<span class="n">exposeToJS</span><span class="p">(</span><span class="n">openDatabase</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Another workaround is to use pass by value semantics, but this might not always work, but at least now you know why your strings are garbage characters.</p>

<h2 id="lambdas">Lambdas</h2>

<p><a href="https://en.cppreference.com/w/cpp/language/lambda">Doc Reference</a></p>

<p>A C++ lambda follows the syntax:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span> <span class="n">captured</span> <span class="n">variables</span> <span class="p">](</span> <span class="n">params</span> <span class="p">)</span> <span class="p">{</span> <span class="n">body</span> <span class="p">}</span>
</code></pre></div></div>

<p>Here is a very simple lambda example of a curried function (<a href="https://javascript.info/currying-partials">currying</a> = fancy word for partially applying functions )</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">createSumN</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">function</span> <span class="n">sum4</span> <span class="o">=</span> <span class="n">createSumN</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>

	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"result of sum4: "</span> <span class="o">&lt;&lt;</span> <span class="n">sum4</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="captured-variables">Captured variables</h3>

<p>In the example I used <code class="language-plaintext highlighter-rouge">[=]</code> as my capture value, this basically copies the entire context of the parent function into the lambda function context, you might want to capture specific values, in that case you want to do something like:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// pass by value/reference still applies here</span>

<span class="c1">// pass by value (will create a copy in the lambda context)</span>
<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">createSumN</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">[</span><span class="n">n</span><span class="p">](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">}</span>

<span class="c1">// pass by reference (will use the same memory address) will basically create garbage if you are not careful and call after parent memory has been re-used</span>
<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">createSumNWrong</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">n</span><span class="p">](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">function</span> <span class="n">sum4</span> <span class="o">=</span> <span class="n">createSumN</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">function</span> <span class="n">sum4Wrong</span> <span class="o">=</span> <span class="n">createSumNWrong</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"result of sum4: "</span> <span class="o">&lt;&lt;</span> <span class="n">sum4</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="c1">// "14"</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"result of sum4: "</span> <span class="o">&lt;&lt;</span> <span class="n">sum4Wrong</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="c1">// who knows, I got "3660"</span>
</code></pre></div></div>

<p>So whatever you are trying to capture by reference make sure that it will be long lived</p>

<h2 id="stdmove">std::move</h2>

<p>There is another trick you need to know that will keep your variables (and lambdas) from being de-allocated: <code class="language-plaintext highlighter-rouge">std::move</code> takes a variable or reference and tells the compiler it is safe to move it‚Äôs memory space to whatever you are passing it to, JSI (and probably the code you will write) uses this extensively:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Assume you are initializing your JSI module, in this case a database module</span>
<span class="c1">// you create a JSI function and now you need to move it to JavaScript global object</span>

<span class="k">auto</span> <span class="n">myOpenFunction</span> <span class="o">=</span> <span class="n">jsi</span><span class="o">::</span><span class="n">Function</span><span class="o">::</span><span class="n">crea</span><span class="p">...</span> <span class="c1">// creates a JSI (read Javascript) function</span>

<span class="n">rt</span><span class="p">.</span><span class="n">global</span><span class="p">()</span>
	<span class="p">.</span><span class="n">setProperty</span><span class="p">(</span><span class="n">rt</span><span class="p">,</span>
							 <span class="s">"open"</span><span class="p">,</span>
							 <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">myOpenFunction</span><span class="p">));</span> <span class="c1">// This will safely move the memory chunk of "myOpenFunction" from the context of this function to the global object</span>
</code></pre></div></div>

<p>If your library returns anything but basic types (int, doubles, etc) you will also have to std::move their structs to avoid them from being thrashed:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">myOpenFunction</span> <span class="o">=</span> <span class="n">jsi</span><span class="o">::</span><span class="n">Function</span><span class="o">::</span><span class="n">create</span><span class="p">...</span> <span class="c1">// creates a JSI (read Javascript) function</span>
											<span class="c1">// bunch of mumbo jumbo</span>
											<span class="p">{</span>
												<span class="n">jsi</span><span class="o">::</span><span class="n">Object</span> <span class="n">response</span> <span class="o">=</span> <span class="n">jsi</span><span class="o">::</span><span class="n">Object</span><span class="p">(</span><span class="n">rt</span><span class="p">);</span> <span class="c1">// creates a JavaScript {} (empty object)</span>
												<span class="n">response</span><span class="p">.</span><span class="n">setProperty</span><span class="p">(</span><span class="n">rt</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">);</span> <span class="c1">// {foo: "bar"}</span>
												<span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">response</span><span class="p">);</span> <span class="c1">// Moves the "response" object from this function scope to the JavaScript runtime to avoid the memory being deleted</span>
											<span class="p">}</span>
</code></pre></div></div>

<h2 id="void-returns">Void returns</h2>

<p>Unlike Javascript, <strong>you need to return your lambda functions</strong> (not to Javascript, just on the C++ side):</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">myOpenFunction</span> <span class="o">=</span> <span class="n">jsi</span><span class="o">::</span><span class="n">Function</span><span class="o">::</span><span class="n">create</span><span class="p">..</span>
											<span class="c1">// bunch of mumbo jumbo</span>
											<span class="p">{</span>
												<span class="p">[]()</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{</span>
													<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"I did some side-effect"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
													<span class="k">return</span> <span class="p">{};</span> <span class="c1">// void return</span>
												<span class="p">}</span>
											<span class="p">}</span>
</code></pre></div></div>

<h1 id="advanced-advanced-stuff">Advanced advanced stuff</h1>

<h2 id="bitwise-operations-masks">Bitwise operations (masks)</h2>

<p>While it is possible to do bit level operations on Javascript is not very common, so you might don‚Äôt know how it works, it is however a fairly standard trick in the C/C++ world</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">int</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// = 0000...01 (binary)</span>
<span class="nx">int</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// = 0000...10 (binary)</span>

<span class="c1">// Do an AND on the bits</span>
<span class="nx">cout</span> <span class="o">&lt;&lt;</span> <span class="nx">a</span> <span class="o">&amp;</span> <span class="nx">b</span> <span class="o">&lt;&lt;</span> <span class="nx">endl</span><span class="p">;</span> <span class="c1">// 0 = 0000...00</span>

<span class="c1">// Do an OR on the bits</span>
<span class="nx">cout</span> <span class="o">&lt;&lt;</span> <span class="nx">a</span> <span class="o">|</span> <span class="nx">b</span> <span class="o">&lt;&lt;</span> <span class="nx">endl</span><span class="p">;</span> <span class="c1">// 3 = 0000...11</span>
</code></pre></div></div>

<p>What kind of madman would use this beside the magicians‚Ä¶ well, a lot of devs use for single flag configurations, here is a theoretical example:</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Let's say I'm creating a user/role module</span>
<span class="c1">// instead of creating enums, string or w/e</span>
<span class="c1">// I can model my permissions as a series of flags</span>
<span class="nx">int</span> <span class="nx">HAS_READ_PERMISSION</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 0000...01</span>
<span class="nx">int</span> <span class="nx">HAS_WRITE_PERMISSION</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 0000...10</span>
<span class="nx">int</span> <span class="nx">HAS_EXECUTE_PERMISSION</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// 000..100</span>
<span class="c1">// ...</span>
<span class="nx">int</span> <span class="nx">HAS_CHESEE_WAREHOUSE_PERMISION</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span> <span class="c1">// 000...10000</span>

<span class="c1">// So then when I want to create permissions for an specific user I can do this cute trick</span>
<span class="nx">int</span> <span class="nx">myUserPermissions</span> <span class="o">=</span> <span class="nx">HAS_READ_PERMISION</span> <span class="o">|</span> <span class="nx">HAS_WRITE_PERMISSION</span> <span class="o">|</span> <span class="nx">HAS_CHESEE_WAREHOUSE_PERMISION</span><span class="p">;</span> <span class="c1">// 000...10101</span>
</code></pre></div></div>

<h2 id="revisiting-pointers">Revisiting pointers</h2>

<p>I superficially introduced pointers to you, I did not want to go deeper because it can be super confusing, however it is important to know everything you can do (and be careful of) with pointers.</p>

<p>For your reference here is the <a href="https://www.cplusplus.com/doc/tutorial/pointers/">cplusplus tutorial</a> on pointers.</p>

<p>Here are some patterns that you might encounter, instead of reading you the theory like the bible, I think it is better to plain explain it</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// SQLite example to "open" a database</span>

<span class="c1">// Remember bit masks?</span>
<span class="nx">int</span> <span class="nx">sqlOpenFlags</span> <span class="o">=</span> <span class="nx">SQLITE_OPEN_READWRITE</span> <span class="o">|</span> <span class="nx">SQLITE_OPEN_CREATE</span><span class="p">;</span>

<span class="nx">sqlite3</span> <span class="o">*</span><span class="nx">db</span><span class="p">;</span> <span class="c1">// Declare a pointer to a sqlite3 type variable, currently empty</span>

<span class="c1">// Exit code to be used by sqlite</span>
<span class="c1">// 0 is considered by everyone and their grandma to be the code when a program has correctly executed it's function</span>
<span class="nx">int</span> <span class="nx">exit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// Mash everything together! üòÆ‚Äçüí®</span>
<span class="c1">// 1) The success (or failure) of the operation will be saved on the exit variable</span>
<span class="c1">// 2) notice the &amp;db: we are passing a pointer to the pointer! Yes that is possible!</span>
<span class="c1">//    sqlite3 will initialize a sqlite3 object and then cram the memory value into the pointer we passed!</span>

<span class="nx">exit</span> <span class="o">=</span> <span class="nf">sqlite3_open_v2</span><span class="p">(</span><span class="dl">"</span><span class="s2">my_database_path</span><span class="dl">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">db</span><span class="p">,</span> <span class="nx">sqlOpenFlags</span><span class="p">,</span> <span class="nx">nullptr</span><span class="p">);</span>

<span class="c1">// The code above will not throw a memory exception, but it will return the return code</span>
<span class="c1">// it falls to us to check the function has correctly opened a SQLite database</span>
<span class="c1">// (SQLITE_OK is just 0)</span>
<span class="k">if </span><span class="p">(</span><span class="nx">exit</span> <span class="o">!=</span> <span class="nx">SQLITE_OK</span><span class="p">)</span> <span class="p">{</span>
<span class="p">...</span>
</code></pre></div></div>

<h2 id="host-objects">Host Objects</h2>

<p>Host objects are just C++ (class) instances that have methods exposed to the JS context. They do not necessarily have a performance advantage, but rather allow to encapsulate and use most of C++ class semantics easily.</p>

<p>To expose a C++ as a HostObject you need to take care of the following:</p>

<ol>
  <li>Inherit from jsi::HostObject</li>
  <li>Override <code class="language-plaintext highlighter-rouge">get</code> and <code class="language-plaintext highlighter-rouge">set</code> to allow access to methods and properties</li>
  <li>Register object on the global object</li>
</ol>

<p>Here is a simple example:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;jsi/jsi.h&gt;</span>
<span class="cp">#import &lt;React/RCTBridge+Private.h&gt;</span>

<span class="n">using</span> <span class="n">namespace</span> <span class="nv">facebook</span><span class="p">::</span><span class="n">jsi</span><span class="p">;</span>
<span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="c1">// Store key-value pairs persistently across launches of your app.</span>
<span class="kd">class</span> <span class="kt">NativeStorage</span> <span class="p">:</span> <span class="kd">public</span> <span class="kt">HostObject</span> <span class="p">{</span>
<span class="nv">public</span><span class="p">:</span>
  <span class="c1">/// Stored property</span>
  <span class="n">int</span> <span class="n">expirationTime</span> <span class="o">=</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">24</span><span class="p">;</span> <span class="c1">// 1 day</span>

  <span class="c1">// Helper function</span>
  <span class="kd">static</span> <span class="kt">NSString</span><span class="o">*</span> <span class="nf">stringValue</span><span class="p">(</span><span class="kt">Runtime</span> <span class="o">&amp;</span><span class="n">runtime</span><span class="p">,</span> <span class="n">const</span> <span class="kt">Value</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">value</span><span class="o">.</span><span class="nf">isString</span><span class="p">()</span>
      <span class="p">?</span> <span class="p">[</span><span class="kt">NSString</span> <span class="nv">stringWithUTF8String</span><span class="p">:</span><span class="n">value</span><span class="o">.</span><span class="nf">getString</span><span class="p">(</span><span class="n">runtime</span><span class="p">)</span><span class="o">.</span><span class="nf">utf8</span><span class="p">(</span><span class="n">runtime</span><span class="p">)</span><span class="o">.</span><span class="nf">c_str</span><span class="p">()]</span>
      <span class="p">:</span> <span class="kc">nil</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">Value</span> <span class="nf">get</span><span class="p">(</span><span class="kt">Runtime</span> <span class="o">&amp;</span><span class="n">runtime</span><span class="p">,</span> <span class="n">const</span> <span class="kt">PropNameID</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
    <span class="n">auto</span> <span class="n">methodName</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="nf">utf8</span><span class="p">(</span><span class="n">runtime</span><span class="p">);</span>

    <span class="c1">// `expirationTime` property getter</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">methodName</span> <span class="o">==</span> <span class="s">"expirationTime"</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">expirationTime</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// `setObject` method</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">methodName</span> <span class="o">==</span> <span class="s">"setObject"</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kt">Function</span><span class="p">::</span><span class="nf">createFromHostFunction</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="kt">PropNameID</span><span class="p">::</span><span class="nf">forAscii</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="s">"setObject"</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span>
                                                        <span class="p">[](</span><span class="kt">Runtime</span> <span class="o">&amp;</span><span class="n">runtime</span><span class="p">,</span> <span class="n">const</span> <span class="kt">Value</span> <span class="o">&amp;</span><span class="n">thisValue</span><span class="p">,</span><span class="n">const</span> <span class="kt">Value</span> <span class="o">*</span><span class="n">arguments</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">count</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Value</span> <span class="p">{</span>
        <span class="kt">NSString</span><span class="o">*</span> <span class="n">key</span> <span class="o">=</span> <span class="nf">stringValue</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="n">arguments</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="kt">NSString</span><span class="o">*</span> <span class="n">value</span> <span class="o">=</span> <span class="nf">stringValue</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="n">arguments</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">length</span> <span class="o">&amp;&amp;</span> <span class="n">value</span><span class="o">.</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
          <span class="p">[</span><span class="kt">NSUserDefaults</span><span class="o">.</span><span class="n">standardUserDefaults</span> <span class="nv">setObject</span><span class="p">:</span><span class="n">value</span> <span class="nv">forKey</span><span class="p">:</span><span class="n">key</span><span class="p">];</span>
          <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
      <span class="p">});</span>
    <span class="p">}</span>
    <span class="c1">// `object` method</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">methodName</span> <span class="o">==</span> <span class="s">"object"</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kt">Function</span><span class="p">::</span><span class="nf">createFromHostFunction</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="kt">PropNameID</span><span class="p">::</span><span class="nf">forAscii</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="s">"object"</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span>
                                                        <span class="p">[](</span><span class="kt">Runtime</span> <span class="o">&amp;</span><span class="n">runtime</span><span class="p">,</span> <span class="n">const</span> <span class="kt">Value</span> <span class="o">&amp;</span><span class="n">thisValue</span><span class="p">,</span><span class="n">const</span> <span class="kt">Value</span> <span class="o">*</span><span class="n">arguments</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">count</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Value</span> <span class="p">{</span>
        <span class="kt">NSString</span><span class="o">*</span> <span class="n">key</span> <span class="o">=</span> <span class="nf">stringValue</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="n">arguments</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="kt">NSString</span><span class="o">*</span> <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="kt">NSUserDefaults</span><span class="o">.</span><span class="n">standardUserDefaults</span> <span class="nv">stringForKey</span><span class="p">:</span><span class="n">key</span><span class="p">];</span>
        <span class="k">return</span> <span class="n">value</span><span class="o">.</span><span class="n">length</span>
          <span class="p">?</span> <span class="kt">Value</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="kt">String</span><span class="p">::</span><span class="nf">createFromUtf8</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="kt">UTF8String</span><span class="p">))</span>
          <span class="p">:</span> <span class="kt">Value</span><span class="p">::</span><span class="nf">undefined</span><span class="p">();</span>
      <span class="p">});</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kt">Value</span><span class="p">::</span><span class="nf">undefined</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">void</span> <span class="nf">set</span><span class="p">(</span><span class="kt">Runtime</span><span class="o">&amp;</span> <span class="n">runtime</span><span class="p">,</span> <span class="n">const</span> <span class="kt">PropNameID</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="n">const</span> <span class="kt">Value</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
    <span class="n">auto</span> <span class="n">methodName</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="nf">utf8</span><span class="p">(</span><span class="n">runtime</span><span class="p">);</span>

    <span class="c1">// ExpirationTime property setter</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">methodName</span> <span class="o">==</span> <span class="s">"expirationTime"</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="nf">isNumber</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">this</span><span class="o">-&gt;</span><span class="n">expirationTime</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="nf">asNumber</span><span class="p">();</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

	<span class="c1">// You can call this method from the entry point where you install the bindings</span>
  <span class="c1">// or call it in another method, we will take a look later</span>
  <span class="c1">// Install `nativeStorage` globally to the runtime</span>
  <span class="kd">static</span> <span class="n">void</span> <span class="nf">install</span><span class="p">(</span><span class="kt">Runtime</span><span class="o">&amp;</span> <span class="n">runtime</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">NativeStorage</span> <span class="n">nativeStorage</span><span class="p">;</span>
    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">NativeStorage</span><span class="o">&gt;</span> <span class="n">binding</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">NativeStorage</span><span class="o">&gt;</span><span class="p">(</span><span class="nf">move</span><span class="p">(</span><span class="n">nativeStorage</span><span class="p">));</span>
    <span class="n">auto</span> <span class="n">object</span> <span class="o">=</span> <span class="kt">Object</span><span class="p">::</span><span class="nf">createFromHostObject</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="n">binding</span><span class="p">);</span>

    <span class="n">runtime</span><span class="o">.</span><span class="nf">global</span><span class="p">()</span><span class="o">.</span><span class="nf">setProperty</span><span class="p">(</span><span class="n">runtime</span><span class="p">,</span> <span class="s">"nativeStorage"</span><span class="p">,</span> <span class="n">object</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h1 id="references">References</h1>

<p>So most of what you see here I learned from the library I implemented: <a href="https://github.com/ospfranco/react-native-quick-sqlite">react-native-quick-sqlite</a>, it is a new wrapper for SQLite3 using JSI bindings, the code is MIT and open source, so feel free to check it out, there are also many other JSI libraries out there, with varying grades of difficulty for you to understand:</p>

<h3 id="libraries-implemented-using-jsi">Libraries implemented using JSI</h3>

<ul>
  <li>https://github.com/mrousavy/react-native-vision-camera</li>
  <li>https://github.com/mrousavy/react-native-mmkv</li>
  <li>https://github.com/mrousavy/react-native-multithreading</li>
  <li>https://github.com/software-mansion/react-native-reanimated</li>
  <li>https://github.com/BabylonJS/BabylonReactNative</li>
  <li>https://github.com/craftzdog/react-native-quick-base64</li>
  <li>https://github.com/craftzdog/react-native-quick-md5</li>
  <li>https://github.com/greentriangle/react-native-leveldb</li>
  <li>https://github.com/expo/expo/tree/master/packages/expo-gl</li>
  <li>https://github.com/ospfranco/react-native-quick-sqlite</li>
  <li>https://github.com/ammarahm-ed/react-native-mmkv-storage</li>
  <li>https://github.com/Nozbe/WatermelonDB</li>
</ul>
</div>
    </div>

    <link
      rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <script>
      hljs.highlightAll();
    </script>
  </div>
</body>

</html>
